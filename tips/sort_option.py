""" 문자 정렬, 중복 제거는 안 함 """
word = input()
a = sorted(word, key=word.find)
print(a)

# --------------------------------------------------------------------------------------

""" 밑의 설정을 입력하면 a의 요소 중 첫번째 요소는 내림차순, 두번째 요소는 오름차순 """
# 앞에 -를 붙이면 내림차순
a = [(6, 10), (2, 3), (4, 5), (1, 7), (6, 8), (9, 10)]
b = sorted(a, key=lambda x: (-x[0], x[1]))
print(b)

# --------------------------------------------------------------------------------------

"""문자열 정렬"""
word = ["ab", "efw", "a", "ee"]
word_ = sorted(word)
word_reverse = sorted(word, reverse=True)

print(word_)  # ['a', 'ab', 'ee', 'efw']
print(word_reverse)  # ['efw', 'ee', 'ab', 'a']

# --------------------------------------------------------------------------------------

"""문자열 정렬 응용, 프로그래머스 정렬 part 중 "2번 가장 큰 수" 참고"""
"""
Q) x: x * 3?
-> 각각의 문자열을 3번 반복하여 정렬한다는 의미
-> numbers 안에 들어있는 숫자가 1000 이하이므로 3자리수로 맞춘 후 비교하는 것
    ex) ["6", "2", "21", "23", "10"] (내림차순 정렬한다고 했을 때)
        1. x * 3을 했기에 ["666", "222", "212121", "232323", "101010"]을 기준으로 정렬
        2. 문자열이기에 첫번째 인덱스부터 아스키코드를 기준으로 정렬
        3. "6"이 가장 크므로 맨 앞
        4. "2"가 동률인 세 개의 값은 두번째 인덱스도 비교한다
        5. 두번째 인덱스를 기준으로 "23", "2", "21"로 정렬된다
        6. 마지막으로 "10"이 정렬된다

Q) 1000이하를 x * 3으로 해야하는 이유?
-> ["9", "991"]에다가 x * 2를 하면 ["99", "991991"]이다
-> 이는 여전히 "991"이 더 큰 값으로 인식된다
-> 그렇기에 최소 x * 3은 해야한다
"""
numbers = ["2", "21", "23", "6", "10"]
numbers.sort(key=lambda x: x * 3, reverse=True)
print(numbers)  # ['6', '23', '2', '21', '10']

# --------------------------------------------------------------------------------------
