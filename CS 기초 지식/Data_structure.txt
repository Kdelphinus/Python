1. Array
- 논리적 저장 순서와 물리적 저장 순서가 일치
- 따라서 인덱스로 해당 원소에 접근 가능, 그렇기에 O(1)로 접근 가능
- 그러나 삽입, 삭제에 경우 원소들을 이동시켜야 하기에 O(n)이 걸린다


2. Linked List
- Array의 삽입, 삭제 시간을 단축하기 위해 고안됨
- 각각의 원소들은 자기 자신 다음에 어떤 원소인지만 기억하고 있음
- 그렇기에 이 값만 바꿔주면 삭제와 삽입이 O(1)밖에 안 걸림
- 그러나 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기에 그 원소를 찾는 과정에서 O(n)이 걸린다
- 결국 탐색, 삽입, 삭제에서 모두 O(n)이 걸린다
- 그러나 Tree 구조의 근간이 되고 유용성이 있기에 사용된다


3. Stack
- Last In First Out(LIFO)
- 나중에 들어간 원소가 먼저 나오는 구조
- 차곡차곡 쌓이는 구조


4. Queue
- First In First Out(FIFO)
- 먼저 들어간 원소가 먼저 나옴
- Stack과 반대


5. Tree
- 스택이나 큐같은 선형 구조가 아닌 비선형 구조이다
- 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조

    5.1. 트리의 구성요소
    - Node(노드): 트리를 구성하는 각각의 요소
    - Edge(간선): 노드와 노드를 연결하는 선
    - Root Node(루트 노드): 트리 구조에서 최상위에 있는 노드
    - Terminal Node(Leaf Node, 단말 노드): 하위에 다른 노드가 연결되지 않은 노드
    - Internal Node(내부 노드, 비단말 노드): 단말 노드를 제외한 모든 노드, 루트 노드도 포함
    - Descendant Node(자손 노드): 어떤 노드에서 단말 노드까지 가는 경로에 포함된 모든 노드

    5.2. Binary Tree(이진 트리)
    - 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어진다
    - 또한 나뉘어진 두 서브 트리도 모두 이진 트리여야 한다
    - 공집합도 이진 트리에 포함된다
    - 또한 노드가 하나 뿐인 것도 이진 트리 정의를 만족한다(그래야만 단말 노드에 이르렀을때도 이진 트리를 만족하기 때문)

    - 각 층별로 Level이라 하며 레벨은 0부터 시작한다
    - 즉, 루트 노드는 레벨 0이다
    - 그리고 트리의 최고 높이를 해당 트리의 height라고 한다

    - 포화 이진 트리(Perfect Binary Tree): 모든 레벨이 꽉 찬 이진 트리
    - 완전 이진 트리(Complete Binary Tree): 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리
    - 정 이진 트리(Full Binary Tree): 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리

    - Binary Tree는 노드의 개수가 n개이고 root가 0이 아닌 1에서 시작할 때, i번째 노드에 대해서
        - parent(i) = i/2
        - left_child(i) = 2i
        - right_child(i) = 2i + 1
      의 인덱스를 갖는다
    
    5.3. BST(Binary Search Tree)
    - 효율적인 탐색을 위해 어떻게 찾을까와 함께 어떻게 저장할지 고민해야 한다
    - 이진 탐색 트리는 어떻게 저장할지를 만들어 탐색을 좀 더 빠르게 한다
    - 이진 탐색 트리 저장 규칙
        - 이진 탐색 트리의 노드에 저장된 키는 유일하다
        - 부모의 키가 왼쪽 자식 노드의 키보다 크다
        - 부모의 키가 오른쪽 자식 노드의 키보다 작다
        - 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다
    - 이러한 이진 탐색 트리의 탐색 연산은 O(logn)이다, 정확히는 O(h)

    - 트리의 높이를 하나씩 더해갈 때 한쪽만 치우치는 편항 트리(Skewed Tree)가 될 수 있다
    - 이때는 성능에 영향을 미치고 시간 복잡도가 O(n)이 된다
    - 메모리를 더 사용하기에 시간 복잡도마저 같게 되면 너무나 비효울적이다
    
    - 이를 막기 위해 Rebalancing 기법을 사용한다
    - Rebalancing은 말그대로 이진 트리의 균형을 잡는 것이다
    - 여러 종류가 있는데 그 중 하나가 Red-Black Tree이다


6. Binary Heap
- Tree 형식을 하고 있으며 Tree 중에서도 Complete Binary Tree이다
- 루트 노드가 0번째를 뛰어넘고 1번째부터 시작된다

- Max Heap: 각 노드의 값이 자식의 값보다 크거나 같은 완전 이진 트리
- Min Heap: 각 노드의 값이 자식의 값보다 작거나 같은 완전 이진 트리

- Max Heap은 최대값이 루트 노드에 있고 Min Heap은 최소값이 루트 노드에 존재한다, 그렇기에 각자 최대값/최소값 찾는데 O(1)이 걸린다
- 하지만 heap을 유지하기 위해 제거된 루트 노드를 대체할 다른 노드가 필요하다
- 여기선 맨 마지막 노드를 루트 노드로 대체한 후, 다시 heapify 과정을 거쳐 heap을 유지한다
- 이때 O(logn)이 걸린다


7. Red-Black Tree(RBT)
- BST를 기반으로 하는 트리 형식의 자료 구조
- 탐색, 삽입, 삭제에서 모두 O(logn)이 걸린다
- 동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심
- depth를 최소화하는 방법은 Complete Binary Tree로 만들면 된다

    7.1. 정의 및 성질
    - 각 노드는 빨강이나 검정의 색을 갖는다
    - 루트 노드의 색깔은 검정이다
    - 각 단말 노드는 검정이다
    - 어떤 노드의 색깔이 빨강이면 두 개의 자식 노드는 모두 검정이다
    - 각 노드에 대해 노드로부터 단말 노드까지 이르는 경로에 포함된 노드들은 모두 같은 수의 검정 노드들을 포함한다
        - 이를 해당 노드의 Black-Height라고 한다
        - Black-Height: 노드 x로부터 노드 x를 포함하지 않는 단말 노드까지 가는 최소 경로에 포함된 검정 노드들의 개수
    
    7.2. 특징
    - 이진 탐색 트리이므로 이진 탐색 트리의 특징은 모두 갖는다
    - 루트 노드부터 단말 노드까지 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다, 이 상태를 balanced 상태라고 한다
    - 노드의 자식이 없을 경우 작시을 가리키는 포인터는 NIL(NULL과 같은 개념) 값을 저장한다, 그리고 NIL을 단말 노드로 간주한다

    7.3. 삽입
    - BST의 특성을 유지하며 삽입한다
    - 삽입된 노드는 빨강으로 지정한다, 이는 Black-Height 변경을 최소화하기 위함이다
    - 삽입 후, RBT의 특성을 위배하면 노드의 색깔을 조정하고 Black-Height가 위배되면 rotation을 통해 height을 조정한다
    - 이 과정을 통해 동일한 level에 존재하는 비단말 노드들의 Black-Height이 같아지게 되고 최소 경로와 최대 경로의 비율이 2미만으로 유지된다

    7.4. 삭제
    - BST의 특성을 유지하며 삭제한다
    - 삭제될 노드의 자식 수에 따라 rotation 방법이 달라진다
    - 지워진 노드가 검정이면 Black-Height을 유지하기 위해 감소한 경로에 검정 노드를 하나 추가되도록 rotation하고 색을 조정한다
    - 지워진 노드가 빨강이면 RBT가 그대로 유지된다


8. Hash Table
- 해쉬는 배열을 사용하기에 빠른 검색 속도를 갖는다
- 그러나 인덱스로 저장되는 key값이 불규칙하기에 특별한 알고리즘을 사용하여 데이터와 연관된 고유한 숫자를 만들어 낸 뒤, 인덱스로 사용한다
- 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치기에 삽입 시 다른 데이터 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없다

    8.1. Hach Function(Hash Method)
    - 위에서 언급한 특별한 알고리즘, 즉 데이터와 연관된 고유한 숫자를 만들어 인덱스로 부여하는 알고리즘
    - 저장되는 값들의 키값을 해시 함수를 이용해 작은 범위의 값들로 바꿔준다

    - 어설픈 해시 함수를 사용하면 다른 데이터들의 key값들을 결정해도 동일한 값이 도출될 수 있다
    - 이렇게 되면 동일한 key값에 여러 개의 데이터가 하나의 테이블에 존재하게 되며 이를 Collision이라 한다

    - 일반적으로 좋은 해시 함수는 키의 전체를 참조하여 해쉬값을 만든다
    - 또한 해시 함수를 무조건 1대1로 만드는 것보다 Collision을 최소화하는 방향으로 설계하고 Collision에 대비해 어떻게 대응할 것인지가 더 중요하다
    - 1대1 대응이 되도록 만드는 것은 거의 불가능하며 만든다해도 그건 배열과 다르지 않고 메모리를 너무 크게 차지한다
    - Collision이 많아질수록 탐색에 필요한 시간 복잡도가 O(1)에서 O(n)에 가까워진다
    - 즉 해시를 해시답게 사용하지 못하게 된다
    - 이를 방지하기위해 충돌 해결은 필수다

    8.2. Resolve Conflict(충돌 해결)
    - 다양한 방법이 있지만 그 방법들의 기본이 되는 두 가지 방법이 있다

        8.2.1. Open Address(개방주소법)
        - 해시 충돌이 발생하면 다른 해시버킷에 해당 자료를 삽입하는 방식
        - 충돌이 발생하면 데이터를 저장할 장소를 찾아 해맨다
        - 최악의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치로 되돌아오게 된다
        - 탐색 방법들
            - Linear probing: 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행
            - Quadratic probing: 2차 함수를 이용해 탐색활 위치를 찾음
            - Double hashing probing: 하나의 해시 함수에서 충돌이 발생하면 2차 해쉬 함수를 이용해 새로운 주소를 할당, 위 두가지 방법보다 연산량을 많이 요구
        
        8.2.2. Separate Chaining(분리 연결법)
        - 일반적으로 개방주소법은 분리 연결법보다 느리다
        - 해시가 채워질수록 충돌 빈도가 올라가고 최악의 경우도 많아지기 때문이다

        - 분리 연결법을 구현하는 방식
            - 연결 리스트를 사용하는 방식
                - 각각의 버킷들을 연결리스트로 만들어 충돌이 발생하면 해당 버킷의 리스트에 추가하는 방식
                - 연결 리스트의 특징에 따라 삽입, 삭제가 간편하다
                - 허나 단점도 그대로 받아 작은 데이터들을 저장할 때 연결 리스트 자체 오버헤드가 부담된다
                - 또다른 특징은 버킷을 계속 사용하는 개방주소법에 비해 테이블의 확장을 늦출 수 있다
            - 트리를 사용하는 방식
                - 기본적으론 분리 연결법과 동일하며 연결 리스트 대신 트리(RBT)를 사용하는 방식
                - 트리와 연결리스트 중 무엇을 사용할지에 대한 기준은 하나의 해시버킷에 할당된 key-value 쌍의 개수이다
                - 데이터가 적으면 연결 리스트를 사용해야 한다(트리는 기본적으로 메모리 사용량이 많기 때문)
        
        - 데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?
            - 해시 버킷에 할당된 key-value 쌍의 개수가 6개, 8개이다
            - 기준이 6, 8인 이유는 하나의 값이 추가되거나 삭제되었을 때 자료구조를 변경하면 변경하는 비용이 너무 크기 때문이다
            - 그렇기에 6에서 7로 증가했을 땐 링크드 리스트의 자료구조를 가지고 있을 것이며 8에서 7로 감소했을 땐 트리의 자료구조를 가지고 있을 것이다

        - 개방주소법 vs 분리 연결법
            - 일단 두 방식 모두 최악엔 O(M)이다
            - 하지만 개방주소법은 분리 연결법에 비해 캐시 효율이 높다, 그렇기에 데이터의 개수가 충분히 적다면 개방주소법이 더 좋다
            - 분리 연결법은 개방주소법과 다르게 버킷을 계속해서 사용하기에 테이블의 확장을 보다 늦출 수 있다

        - Supplement hash function(보조 해시 함수)
            - key이 해시 값을 변형해 해시 충돌 가능성을 줄이는 것이 목적
            - 분리 연결법을 사용할 때 사용되며 보조 해시 함수로 최악의 경우로 가는 경우를 줄일 수 있다
        
    8.3. 해시 버킷 동적 확장(Resize)
    - 해시 버킷 수가 적다면 메모리 사용은 아낄 수 있지만 해시 충돌로 인해 성능 손실이 발생한다
    - 그렇기에 HashMap은 key-value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘린다
    - 이렇게 늘리면 해시 충돌로 인한 성능 손실을 어느정도 막을 수 있다
    - 이떄 '일정 개수 이상'은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이며 0.75를 load factor라고 부른다


9. Graph
- 정점과 간선의 집합
- Tree 역시 그래프의 일종이며 사이클이 허용되지 않는 그래프이다

    9.1. 그래프 관련 용어
    - Vertex: 정점
    - Edge: 간선
    - Undirected Graph: 정점과 간선의 연결관계에 방향성이 없는 그래프
    - Directed Graph: 정점과 간선의 연결관계에 방향성이 있는 그래프

    - Degree
        - Undirected Graph에서: 각 정점에 연결된 간선의 개수
        - Directed Graph에서
            - Outdegree: 각 정점으로부터 나가는 간선의 개수
            - Indegree: 각 정점으로부터 들어오는 간선의 개수
    
    - Weight Graph(가중치 그래프): 간선에 가중치 정보가 있는 그래프, 가중치가 동일하거나 없는 그래프도 물론 존재
    - Sub Graph(부분 그래프): 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프

    9.2. 그래프를 구현하는 방법
    - 인접 행렬(adjacent matrix)
        - 정방 행렬을 사용하는 방법
        - 해당하는 위치의 value값을 통해 정점 간의 연결 관계를 O(1)로 파악할 수 있다
        - 간선의 개수와 무관하게 V^2의 공간 복잡도를 갖는다
        - Dense Graph를 표현할 때 적절하다

    - 인접 리스트(adjacent list)
        - 연결 리스트를 사용하는 방법
        - 정점의 인접 리스트를 확인해야 하기에 정점 간 연결되어있는지 확인하는데 오래 걸린다
        - O(E + V)의 공간복잡도를 가진다
        - Sparse Graph를 표현하는 데 적당하다

    9.3. 그래프 탐색
        9.3.1. 깊이 우선 탐색(Depth First Search, DFS)
        - 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아가는 방법을 우선으로 탐색
        - 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더이상 연결할 정점이 없다면 이전 정점으로 돌아가 연결할 정점이 있는지 확인
        - stack을 사용한다
        - 시간복잡도는 O(V + E), 정점 개수 + 간선 개수

        9.3.2. 너비 우선 탐색(Breadth First Search, BFS)
        - 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다
        - 레벨순으로 탐색한다
        - queue로 구현된다
        - 우선 탐색을 시작할 정점을 queue에 넣고 정점을 방문하며 순서대로 queue에 저장하고 방문한 곳은 queue에서 빼는 방식
        - 시간복잡도는 O(V + E)이다
        - BFS로 구한 경로는 최단 경로이다

    9.4. Minimum Spanning Tree
    - Spanning Tree: 그래프 G의 모든 정점이 사이클 없이 연결된 형태
    - 그래프 G의 Spanning Tree 중 간선 가중치의 합이 최소인 Spanning Tree를 말한다

    9.5. Kruskal Algorithm
    - 초기화 작업으로 간선 없이 정점들로만 그래프를 구성한다
    - 그리고 가중치가 가장 작은 간선부터 검토한다
        - 그러기 위해 간선 세팅을 비내림차순(내림차순이 아닌 정렬)으로 정렬해야 한다
        - 그리고 가장 작은 가중치에 해당하는 간선을 추가하는데 추가할 때 그래프에 사이클이 생기지 않는 경우에만 추가한다
    - Spanning Tree가 완성되면 모든 정점들이 연결된 상태로 종료가 되고 완성될 수 없는 그래프에 대해서는 모든 간선에 대해 판단이 이루어지면 종료된다

        9.5.1. 어떻게 사이클 생성 여부를 판단하는가?
        - 그래프의 각 정점에 set-id를 추가적으로 부여한다
        - 그리고 초기화 과정에서 모두 1~n까지의 값으로 각각의 정점들을 초기화한다
            - 여기서 0은 어떤 간선과도 연결되지 않았음을 의미한다
        - 그 후, 연결할 때마다 set-id를 하나로 통일시키는데 값이 동일한 set-id 개수가 많은 set-id로 통일시킨다
    
        9.5.2. 시간복잡도
        - 간선의 가중치를 기준으로: 정렬 - O(ElogE)
        - 사이클 생성 여부를 검사하고 set-id를 통일하는 과정 - O(E + VlogV) = 전체 시간 복잡도 = O(ElogE)

    9.6. Prim Algorithm
    - 초기화 과정에서 한 개의 정점으로 이루어진 초기 그래프 A를 구성한다
    - 그 후, 그래프 A 내부에 있는 정점으로부터 외부에 있는 정점 사이의 간선을 연결하는데 그 중 가장 작은 가중치의 간선을 통해 연결되는 정점을 추가한다
        - 어떤 정점이든 상관없이 간선의 가중치를 기준으로 연결하는 것
    - 이렇게 연결된 정점은 그래프 A에 포함된다
    - 위 과정을 반복하고 모든 정점들이 연결되면 종료한다
    - 시간복잡도: O(ElogV)
