1. HTTP의 GET과 POST
- 둘 다 HTTP 프로토콜을 이용해서 서버에 무엇인가 요청할 때 사용하는 방식
- 허나 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 사용해야 한다

    1.1. GET
    - 요청하는 데이터가 HTTP Request Message의 헤더 부분에 url이 담겨서 전송되는 방식
    - 때문에url 상 ? 뒤에 데이터가 붙어 request를 보내게 되는 것
    - 이 방식은 url이란 공간에 담겨가기에 데이터 크기가 제한적이며 데이터가 url에 그대로 노출되기에 보안이 필요한 데이터엔 적절치 않다
    - 서버에서 어떤 데이터를가져와서 보여주는 용도, 서버의 값이나 상태를 변경하지 않음
    - 또한 브라우저에서 Caching 할 수 있다, 그렇기에 기존에 Caching되었던 데이터가 응답할 가능성이 존재한다

    1.2. POST
    - HTTP Request Message의 body부분에 데이터가 담겨서 전송된다
    - 그렇기에 바이너리 데이터를 요청하는 경우 GET보다 데이터 크기를 크고 보안은 더 좋게 보낼 수 있다
        - 그러나 암호화를 하지 않으면 보안은 GET과 다를바 없다
    - 서버의 값이나 상태를 변경하거나 추가하기 위해 사용된다


2. TCP 3-way/4-way Handshake
- 설명과 그림 링크: https://asfirstalways.tistory.com/356

    2.1. 연결 성립(Connection Establishment) / 3-way Handshake
    - 클라이언트는 서버에 접속을 요청하는 SYN(a) 패킷을 보낸다
    - 서버는 클라이언트의 요청인 SYN(a)을 받고 클라이언트에게 요청을 수락한다는 ACK(a + 1)와 SYN(b)이 설정된 패킷을 발송한다
    - 클라이언트는 서버의 수락 응답인 ACK(a + 1)와 SYN(b) 패킷을 받고 ACK(b + 1)를 서버로 보내면 연결이 성립된다

    2.2. 연결해제(Connection Termination) / 4-way Handshake
    - 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다
    - 서버는 클라이언트의 요청을 받고 알겠다는 확인 메세지로 ACK를 보낸다
        - 그리고나서 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 된다
    - 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다
    - 클라이언트는 FIN 메세지를 확인했다는 ACK를 보낸다
    - 클라이언트의 ACK를 받은 서버는 소켓 연결을 close한다
    - 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다(TIME_WAIT)

    2.3. SYN과 ACK
    - SYN: synchronize sequence number
    - ACK: acknowledgement
    - TCP Header에는 Code Bit(Flag bit)이란 부분이 존재한다
        - 이 부분은 총 6bit로 이루어져 있으며 각각 한 bit마다 의미를 가지고 있다
        - Urg-Ack-Psh-Rst-Syn-Fin 순서
        - 해당 위치의 비트가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지 나타낸다
        - SYN 패킷이면 000010, ACK 패킷이면 010000이 되는 것이다
    
    2.4. 왜 3-way인가?
    - 클라이언트가 자신의 목소리가 들리는지 물어보고(SYN) 서버는 클라이언트의 목소리가 들린다고 말한다(SYN + 1)
    - 그리고 서버는 자신의 목소리가 들리는지 물어보고(ACK) 클라이언트는 서버의 목소리가 들린다고 말한다(ACK + 1)

    2.5. 왜 SYN을 랜덤한 숫자로 보내는가?
    - 초기 sequence number를 ISN이라고 한다
    - 이때 ISN이 0부터 시작하지 않는다
    - 왜냐하면 연결할 때 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다
    - 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다
    - 서버 측은 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적 number가 전송된다면 이전의 연결로부터 오는 패킷으로 인식할 수도 있다
    - 이를 막기 위해 ISN을 난수로 설정한다


3. TCP와 UDP의 비교
    3.1. UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)
    - 비연결형 프로토콜
    - IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공
    - 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않고 사용자 프로세스의 몫으로 남긴다
    - UDP가 행하는 것은 프로토콜을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다
    
    - 짧은 요청을 보내고 짧은 응답을 기대할 수 있으며 요청/응답이 손실되어 time out되고 다시 시도할 수 있다
    - TCP처럼 초기설정에서 요구되는 프로토콜보다 적은 메세지만 필요하며 코드가 간단하다

    - UDP가 사용된 것에는 DNS가 있다
    - 어떤 호스트의 네임의 IP 주소를 찾을 필요가 있는 프로그램은 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다
    - 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다
    - 사전에 설정이 필요하지 않고 그 후 해제도 필요하지 않다

    3.2. TCP(Transmission Control Protocol, 전송제어 프로토콜)
    - UDP로는 할 수 없고 대부분 인터넷 응용 분야에서 필요한 신뢰성과 순차적인 전달을 위해 TCP가 생겼다
    - TCP는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 특별 설계되었다
    - TCP 서비스는 송,수신자 모두 소켓이라 부르는 종단점을 생성함으로써 이루어진다
    - 연결 설정엔 3-way Handshake를 통해 이루어진다

    - 모든 TCP 연결은 전이중, 점대점 방식이다
        - 전이중(full-duplex): 전송이 양방향으로 동시에 일어날 수 있다는 의미
        - 점대점(point to point): 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미
    - TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다


4. HTTP와 HTTPS
    4.1. HTTP의 문제점
        4.1.1. HTTP는 평문 통신이기에 도청이 가능하다
        - TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다
        - 패킷을 수집하는 것만으로 도청할 수 있으며 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화를 해야한다
        - 보안 방법
            - 통신 자체를 암호화 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로 HTTP의 통신 내용을 암호화할 수 있다
            - SSL을 조합한 HTTP를 HTTPS(HTTP Secure)이나 HTTP over SSL이라고 부른다

            - 다른 방법으론 콘텐츠를 암호화, 말 그대로 HTTP를 사용해서 운반하는 내용인 HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다
            - 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다

        4.1.2. 통신 상대를 확인하지 않기 때문에 위장이 가능하다
        - HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리는 없기에 누구든지 리퀘스트를 보낼 수 있다
        - IP 주소나 포트 등에서 웹 서버에 액세스 제한이 없는 경우, 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환하며 이는 여러 문제를 유발한다
            - 리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지 확인할 수 없다
            - 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할 수 없다
            - 통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다
            - 어디에서 누가 리퀘스트 했는지 확인할 수 없다
            - 의미없는 리퀘스트도 수신한다 -> DoS 공격을 방지할 수 없다
        
        - 보완방법
            - SSL로 상대를 확인할 수 있다
            - SSL은 상대를 확인하는 수단으로 증명서를 제공하고 있다
            - 증명서는 신뢰할 수 있는 제 3자 기관에 의해 발행되기에 서버나 클라이언트가 실재하는 사실을 증명한다
            - 증명서를 통해 사용자는 서버에게 내가 통신하고자 하는 서버임을 나타내고 사용자는 개인 정보 누설 등의 위험성을 줄일 수 있다
            - 또한 클라이언트는 이 증명서로 본인 확인을 하고 웹 사티으 인증에서도 사용할 수 있다

        4.1.3. 완전성을 증명할 수 없기에 변조가 가능하다
        - 여기서 완정성이란 정보의 정확성을 의미한다
        - 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다는 것을 보장할 수 없다
        - 중간에 변조되어도 알 수 없으며 이렇게 중간에 공격자가 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle)이라고 한다

        - 보완방법
            - MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 할 수 있는 것은 아니다
            - 확실히 방지하기 위해선 HTTPS를 사용해야 한다
            - SSL이 인증, 암호화, 다이제스트 기능을 제공하고 있기 때문이다
        
    4.2. HTTPS
    - SSL의 껍질을 덮어쓴 HTTP라고 할 수 있다
    - 그렇기에 HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니고 통신하는 소켓 부분을 SSL 또는 TLS라는 프로토콜로 대체하는 것 뿐이다
    - HTTP는 TCP와 직접 통신했지만 HTTPS는 HTTP -> SSL -> TCP로 통신이 이루어진다, 그렇기에 암호화와 증명서, 안정성을 보장한다
    
    - HTTPS의 SSL에선 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다
    - 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식이다
    
    - 원래 HTTPS는 평문 통신에 비해 CPU나 메모리 등 리소스를 더 많이 요구한다, 그렇기에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어든다
    - 그러나 최근 하드웨어의 발달로 HTTPS를 사용해도 속도 저하가 거의 일어나지 않으며 새로운 표준인 HPPT 2.0을 함께 이용하면 오히려 HTTPS가 HTTP보다 빠르게 동작한다
    - 그렇기에 과거엔 민감한 정보에만 HTTPS를 사용했다면 현재는 모든 웹 페이지에서 HTTPS를 사용하는 방향으로 바뀌고 있다


5. DNS round robin 방식의 문제점
    5.1. 서버의 수 만큼 공인 IP 주소가 필요함
    - 부하 분산을 위해 서버의 대수를 늘리려면 그 만큼의 공인 IP가 필요하다

    5.2. 균등하게 분산되지 않음
    - 스마트폰의 접속은 캐리어 게이트웨이라고 하는 프록시 서버를 경유한다
    - 프록시 서버에서는 이름변환 결과가 일정 시간동안 캐싱되므로 같은 프록시 서버를 경유하는 접속은 항상 같은 서버로 접속된다
    - 또한 PC용 웹브라우저도 DNS 질의 결과를 캐싱하기에 균등하게 분산되지 않는다
    - DNS레코드의 TTL값을 짧게 설정함으로 어느 정도 해소는 되지만 TTL에 따라 캐시를 해제하는 것은 아니기에 주의가 필요하다

    5.3. 서버가 다운되도 확인불가
    - DNS서버는 웹 서버의 부하나 접속 수 등의 상황에 따라 질의결과를 제어할 수 없다
    - 웹 서버의 부하가 높아서 응답이 느려지거나 접속수가 꽉 차서 접속을 처리할 수 없는 상황인 지 감지할 수 없기에 어떤 원인으로 다운되더라도 검출하지 못한 채 유저에게 전달한다
    - 그렇기에 유저들은 간혹 다운된 서버로 연결되기도 한다
    - DNS round robin은 부하분산을 위한 방법이지 다중화 방법은 아니므로 다른 S/W와 조합하여 관리할 필요가 있다

    5.4. round robin 방식을 기반으로 단점을 해소하는 DNS 스케줄링 알고리즘 일부
        5.4.1. Weighted round robin(WRR)
        - 각각의 웹 서버에 가중치를 가미해서 분산 비율을 변경한다
        - 물론 가중치가 큰 서버일수록 빈번하게 선택되므로 처리능력이 높은 서버의 가중치를 높게 설정하는 것이 좋다

        5.4.2. Least Connection
        - 접속 클라이언트 수가 가장 적은 서버를 선택한다
        - 로드밸런서에서 실시간으로 Connection 수를 관리하거나 각 서버에서 주기적으로 알려주는 것이 필요하다

    
6. 웹 통신의 큰 흐름
- 우리가 Chrome을 실행시켜 주소창에 특정 URL값을 입력시키면 어떤 일이 일어나는가?

    6.1. 브라우저
    - 과정
        - url에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사한다
        - 조사된 의미에 따라 HTTP Request 메시지를 만든다
        - 만들어진 메시지를 웹 서버로 전송한다

    - 이때 만들어진 메시지 전송은 브라우저가 직접하는 것은 아니다, 브라우저는 메시지를 네트워크에 송출하는 기능이 없다
    - 그렇기에 메시지 송출은 OS에 의뢰하여 전달한다
    - 단 OS에 송신을 의뢰할 땐 도메인명이 아니라 ip주소로 메시지를 받을 상대를 지정해야 하는데 이 과정에서 DNS서버를 조회해야 한다

    6.2. 프로토콜 스택, LAN 어댑터
    - 과정
        - 프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어)이 브라우저로부터 메시지를 받는다
        - 브라우저로부터 받은 메시지를 패킷 속에 저장한다
        - 수신처 주소 등의 제어정보를 덧붙인다
        - 패킷을 LAN 어댑터에 넘긴다
        - LAN 어댑터는 다음 Hop의 MAC주소를 붙인 프레임을 전기신호로 변환한다
        - 신호를 LAN케이블에 송출시킨다
    - 프로토콜 스택은 통신 중 오류가 발생했을 때, 제어 정보를 사용하여 고쳐 보내거나 각종 상황을 조절하는 등의 역할을 수행한다
    - 프로토콜 스택은 여기서 물건만 받으면 받는 사람의 주소과 각종 유의사항을 써주는 것이다

    6.3. 허스, 스위치, 라우터
    - 과정
        - LAN 어댑터가 송신한 프레임은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다
        - 라우터는 패킷을 프로바이더(통신사)에게 전달한다
        - 인터넷으로 들어가게 된다
    
    6.4. 엑세스 회선, 프로바이더
    - 과정 
        - 패킷은 인터넷의 입구에 있는 엑세스 회선(통신 회선)에 의해 POP(point of presence, 통신사용 라우터)까지 운반된다
        - POP를 거쳐 인터넷의 핵심부로 들어간다
        - 수 많은 고속 라우터들 사이로 패킷이 목적지를 향해 흘러간다

    6.5. 방화벽, 캐시서버
    - 과정
        - 패킷은 인터넷 핵심부를 통과하여 웹 서버측의 LAN에 도착한다
        - 기다리고 있던 방화벽이 도착한 패킷을 검사한다
        - 패킷이 웹 서버까지 가야하는지 가지 않아도 되는지 판단하는 캐시서버가 존재한다
    - 캐시서버에 데이터가 있으면 굳이 서버에 의뢰하지 않고 바로 그 값을 읽을 수 있다
    - 페이지의 데이터 중 다시 이용할 수 있는 것이면 캐시서버에 저장된다

    6.6. 웹 서버
    - 과정 
        - 패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택은 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘긴다
        - 메시지를 받은 웹 서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송한다
        - 왔던 방식대로 응답 메시지가 클라이언트에게 전달된다
