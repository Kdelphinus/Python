1. HTTP의 GET과 POST
- 둘 다 HTTP 프로토콜을 이용해서 서버에 무엇인가 요청할 때 사용하는 방식
- 허나 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 사용해야 한다

    1.1. GET
    - 요청하는 데이터가 HTTP Request Message의 헤더 부분에 url이 담겨서 전송되는 방식
    - 때문에url 상 ? 뒤에 데이터가 붙어 request를 보내게 되는 것
    - 이 방식은 url이란 공간에 담겨가기에 데이터 크기가 제한적이며 데이터가 url에 그대로 노출되기에 보안이 필요한 데이터엔 적절치 않다
    - 서버에서 어떤 데이터를가져와서 보여주는 용도, 서버의 값이나 상태를 변경하지 않음
    - 또한 브라우저에서 Caching 할 수 있다, 그렇기에 기존에 Caching되었던 데이터가 응답할 가능성이 존재한다

    1.2. POST
    - HTTP Request Message의 body부분에 데이터가 담겨서 전송된다
    - 그렇기에 바이너리 데이터를 요청하는 경우 GET보다 데이터 크기를 크고 보안은 더 좋게 보낼 수 있다
        - 그러나 암호화를 하지 않으면 보안은 GET과 다를바 없다
    - 서버의 값이나 상태를 변경하거나 추가하기 위해 사용된다


2. TCP 3-way/4-way Handshake
- 설명과 그림 링크: https://asfirstalways.tistory.com/356

    2.1. 연결 성립(Connection Establishment) / 3-way Handshake
    - 클라이언트는 서버에 접속을 요청하는 SYN(a) 패킷을 보낸다
    - 서버는 클라이언트의 요청인 SYN(a)을 받고 클라이언트에게 요청을 수락한다는 ACK(a + 1)와 SYN(b)이 설정된 패킷을 발송한다
    - 클라이언트는 서버의 수락 응답인 ACK(a + 1)와 SYN(b) 패킷을 받고 ACK(b + 1)를 서버로 보내면 연결이 성립된다

    2.2. 연결해제(Connection Termination) / 4-way Handshake
    - 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다
    - 서버는 클라이언트의 요청을 받고 알겠다는 확인 메세지로 ACK를 보낸다
        - 그리고나서 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 된다
    - 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다
    - 클라이언트는 FIN 메세지를 확인했다는 ACK를 보낸다
    - 클라이언트의 ACK를 받은 서버는 소켓 연결을 close한다
    - 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다(TIME_WAIT)

    2.3. SYN과 ACK
    - SYN: synchronize sequence number
    - ACK: acknowledgement
    - TCP Header에는 Code Bit(Flag bit)이란 부분이 존재한다
        - 이 부분은 총 6bit로 이루어져 있으며 각각 한 bit마다 의미를 가지고 있다
        - Urg-Ack-Psh-Rst-Syn-Fin 순서
        - 해당 위치의 비트가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지 나타낸다
        - SYN 패킷이면 000010, ACK 패킷이면 010000이 되는 것이다
    
    2.4. 왜 3-way인가?
    - 클라이언트가 자신의 목소리가 들리는지 물어보고(SYN) 서버는 클라이언트의 목소리가 들린다고 말한다(SYN + 1)
    - 그리고 서버는 자신의 목소리가 들리는지 물어보고(ACK) 클라이언트는 서버의 목소리가 들린다고 말한다(ACK + 1)

    2.5. 왜 SYN을 랜덤한 숫자로 보내는가?
    - 초기 sequence number를 ISN이라고 한다
    - 이때 ISN이 0부터 시작하지 않는다
    - 왜냐하면 연결할 때 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다
    - 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다
    - 서버 측은 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적 number가 전송된다면 이전의 연결로부터 오는 패킷으로 인식할 수도 있다
    - 이를 막기 위해 ISN을 난수로 설정한다


3. TCP와 UDP의 비교
    3.1. UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)
    - 비연결형 프로토콜
    - IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공
    - 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않고 사용자 프로세스의 몫으로 남긴다
    - UDP가 행하는 것은 프로토콜을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다
    
    - 짧은 요청을 보내고 짧은 응답을 기대할 수 있으며 요청/응답이 손실되어 time out되고 다시 시도할 수 있다
    - TCP처럼 초기설정에서 요구되는 프로토콜보다 적은 메세지만 필요하며 코드가 간단하다

    - UDP가 사용된 것에는 DNS가 있다
    - 어떤 호스트의 네임의 IP 주소를 찾을 필요가 있는 프로그램은 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다
    - 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다
    - 사전에 설정이 필요하지 않고 그 후 해제도 필요하지 않다

    3.2. TCP(Transmission Control Protocol, 전송제어 프로토콜)
    - UDP로는 할 수 없고 대부분 인터넷 응용 분야에서 필요한 신뢰성과 순차적인 전달을 위해 TCP가 생겼다
    - TCP는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 특별 설계되었다
    - TCP 서비스는 송,수신자 모두 소켓이라 부르는 종단점을 생성함으로써 이루어진다
    - 연결 설정엔 3-way Handshake를 통해 이루어진다

    - 모든 TCP 연결은 전이중, 점대점 방식이다
        - 전이중(full-duplex): 전송이 양방향으로 동시에 일어날 수 있다는 의미
        - 점대점(point to point): 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미
    - TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다


4. HTTP와 HTTPS
    4.1. HTTP의 문제점
        4.1.1. HTTP는 평문 통신이기에 도청이 가능하다
        - TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다
        - 패킷을 수집하는 것만으로 도청할 수 있으며 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화를 해야한다
        - 보안 방법
            - 통신 자체를 암호화 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로 HTTP의 통신 내용을 암호화할 수 있다
            - SSL을 조합한 HTTP를 HTTPS(HTTP Secure)이나 HTTP over SSL이라고 부른다

            - 다른 방법으론 콘텐츠를 암호화, 말 그대로 HTTP를 사용해서 운반하는 내용인 HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다
            - 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다

        4.1.2. 통신 상대를 확인하지 않기 때문에 위장이 가능하다
        - HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리는 없기에 누구든지 리퀘스트를 보낼 수 있다
        - IP 주소나 포트 등에서 웹 서버에 액세스 제한이 없는 경우, 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환하며 이는 여러 문제를 유발한다
            - 리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지 확인할 수 없다
            - 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할 수 없다
            - 통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다
            - 어디에서 누가 리퀘스트 했는지 확인할 수 없다
            - 의미없는 리퀘스트도 수신한다 -> DoS 공격을 방지할 수 없다
        
        - 보완방법
            - SSL로 상대를 확인할 수 있다
            - SSL은 상대를 확인하는 수단으로 증명서를 제공하고 있다
            - 증명서는 신뢰할 수 있는 제 3자 기관에 의해 발행되기에 서버나 클라이언트가 실재하는 사실을 증명한다
            - 증명서를 통해 사용자는 서버에게 내가 통신하고자 하는 서버임을 나타내고 사용자는 개인 정보 누설 등의 위험성을 줄일 수 있다
            - 또한 클라이언트는 이 증명서로 본인 확인을 하고 웹 사티으 인증에서도 사용할 수 있다

        4.1.3. 완전성을 증명할 수 없기에 변조가 가능하다
        - 여기서 완정성이란 정보의 정확성을 의미한다
        - 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다는 것을 보장할 수 없다
        - 중간에 변조되어도 알 수 없으며 이렇게 중간에 공격자가 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle)이라고 한다

        - 보완방법
            - MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 할 수 있는 것은 아니다
            - 확실히 방지하기 위해선 HTTPS를 사용해야 한다
            - SSL이 인증, 암호화, 다이제스트 기능을 제공하고 있기 때문이다
        
    4.2. HTTPS
    - SSL의 껍질을 덮어쓴 HTTP라고 할 수 있다
    - 그렇기에 HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니고 통신하는 소켓 부분을 SSL 또는 TLS라는 프로토콜로 대체하는 것 뿐이다
    - HTTP는 TCP와 직접 통신했지만 HTTPS는 HTTP -> SSL -> TCP로 통신이 이루어진다, 그렇기에 암호화와 증명서, 안정성을 보장한다
    
    - HTTPS의 SSL에선 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다
    - 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식이다
    
    - 원래 HTTPS는 평문 통신에 비해 CPU나 메모리 등 리소스를 더 많이 요구한다, 그렇기에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어든다
    - 그러나 최근 하드웨어의 발달로 HTTPS를 사용해도 속도 저하가 거의 일어나지 않으며 새로운 표준인 HPPT 2.0을 함께 이용하면 오히려 HTTPS가 HTTP보다 빠르게 동작한다
    - 그렇기에 과거엔 민감한 정보에만 HTTPS를 사용했다면 현재는 모든 웹 페이지에서 HTTPS를 사용하는 방향으로 바뀌고 있다


5. DNS round robin 방식

