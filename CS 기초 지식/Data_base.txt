1. 데이터베이스
    1.1. 데이터베이스를 사용하는 이유
    - 데이터베이스 이전에 사용하던 파일 시스템은 데이터 종속성 문제와 데이터 무결성 문제가 있었다
    - 이를 보완하기 위해 데이터베이스 사용
    - 파일 시스템도 부분적으론 사용

    1.2. 데이터베이스의 특징
        1.2.1. 데이터의 독립성
        - 물리적 독립성: 데이터베이스 사이즈나 데이터 파일을 늘려도 관련된 응용프로그램을 수정할 필요가 없다
        - 논리적 독립성: 데이터베이스는 논리적 구조로 다양한 응용 프로그램의 논리적 요구를 만족시킬 수 있다

        1.2.2. 데이터의 무결성
        - 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능
        - 데이터의 유효성 검사로 무결성을 구현

        1.2.3. 데이터의 보안성
        - 계정 관리, 접근 권한을 설정함으로 데이터에 보안을 구현

        1.2.4. 데이터의 일관성
        - 연관된 정보를 논리적 구조로 관리하여 어떤 하나의 데이터만 변경했을 경우 발생하는 데이터의 불일치성을 배제할 수 있음
        - 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있음

        1.2.5. 데이터 중복 최소화
        - 데이터를 통합해서 관리하기에 자료의 중복과 데이터의 중복 문제를 해결할 수 있다

    1.3. 데이터베이스의 성능
    - 성능은 디스크 I/O를 어떻게 줄이느냐에서 시작된다
        - 디스크 I/O
            - 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미
            - 이때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정됨
            - 즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하냐로 결정됨

    - 그렇기에 순차 I/O가 랜덤 I/O보다 빠를 수 밖에 없다
    - 그러나 현실에선 대부분 랜덤을 사용하고 이를 바꿀순 없을까라는 생각에서 시작된 데이터베이스 쿼리 튜닝은 랜던 I/O 자체를 줄여주는 것이 목적이다


2. Index
- 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 될 것이다
- DBMS도 모든 테이블을 검색해서 원하는 결과를 찾기 어렵기에 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 둔다
- DBMS의 인덱스는 항상 정렬된 상태를 유지하기에 원하는 값을 탐색하는데는 빠르지만 값을 추가, 삭제, 수정하는 경우 쿼리문 실행 속도가 느려진다
- 즉, DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 읽기 속도를 높이는 기능이다
- 저장 기능에 인덱스를 많이 사용하면 오히려 역효과가 일어날 수 있다

    2.1. Index 자료구조
        2.1.1. B+-Tree 인덱스 알고리즘
        - 일반적으로 사용되는 인덱스 알고리즘
        - 칼럼의 값을 변형하지 않고(정확힌 값의 앞부분만 잘라서 관리) 원래의 값을 이용해 인덱싱하는 알고리즘

        2.1.2. Hash 인덱스 알고리즘
        - 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘
        - 매우 빠른 검색을 지원하지만 값을 변형하여 인덱싱하기에 전방 일치(특정 문자로 시작하는 검색하는 것)와 같이 일부만으로 검색할 땐 사용할 수 없다
        - 주로 메모리 기반의 데이터베이스에서 많이 사용
        
        - Hash 인덱스 알고리즘은 시간복잡도가 O(1)이지만 등호 연산이 아닌 부등호 연산을 할 수 없기에 B+-Tree로 인덱스를 많이 생성한다

    2.2. Primary Index vs Secondary Index
    - 클러스터(Cluster)란 여러 개를 하나로 묶는다는 의미로 주로 사용
    - 클러스터드 인덱스는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데 이는 주로 비슷한 값들을 동시 조회하는 경우가 많다는 점에서 착안한 것
    - 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터를 말한다

    - 클러스터드 인덱스는 프라이머리 키에 대해서만 적용된다 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것이다
    - 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 레코드의 물리적 위치도 변경되어야 한다
    - 그렇기에 프라이머리 키를 신중히 결정해야 한다

    - 클러스터드 인덱스는 테이블 당 한 개(프라이머리 키가 하나이기에), non 클러스터드 인덱스는 테이블 당 여러 개 생성할 수 있다

    2.3. Composite Index
    - 인덱스로 설정하는 필드의 속성도 중요하다
    - 제목, 작가 순서로 인덱스를 결정하면 제목을 찾을 땐 인덱스 효과를 볼 수 있지만 작가만 찾으면 인덱스를 생성한 것이 소용없다

    2.4. Index의 성능과 고려해야할 사항
    - 인덱스를 생성하면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생한다
    - 이때 INSERT는 데이터 추가로 성능의 손실을, DELETE는 삭제하는 것이 아닌 사용 안한다는 표시로만 남는다. 즉, 실제 데이터는 10만건인데 데이터가 100만건 있는 결과가 나올 수 있다

    - 더 중요한 것은 데이터 형식에 따라 인덱스가 효율적인 것도, 비효율적인 것도 존재한다
    - 이름, 나이, 성별이 있을 때 이름을 인덱스하는 것이 가장 효율적이다
    - 나이나 성별은 범위가 넓어서 인덱스 후에도 디스크 I/O가 또 발생하기에 비효율적이다


3. 정규화
- 갱신 이상을 방지하기 위해 정규화 과정을 거친다
    - 갱신 이상
        - 삽입 이상: 원하지 않는 자료가 삽입되거나 자료가 부족해 삽입이 되지 않은 문제
        - 삭제 이상: 하나의 자료만 삭제하려 했지만 그 자료가 포함된 튜플 전체가 삭제되어 정보 손실이 발생되는 문제
        - 수정(갱신) 이상: 정확하지 않거나 일부만 갱신되어 정보가 모호해지거나 일관성이 없어져 정보 파악이 어려운 문제

    3.1. 종류
        3.1.1. 제 1정규형
        - 애트리뷰트의 도메인이 오직 원자값만 포함하고 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다
        - 여러 값을 가지거나, 단일값 두 개가 복합이거나 중복된 값을 가지면 안된다는 것이다

        3.1.2. 제 2정규형
        - 모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해 완전 함수적 종속이여야 한다
        - 키가 아닌 열들이 각각 후보키에 대해 결정되는 형태

        3.1.3. 제 3정규형
        - 어떠한 비주요 애트리뷰트도 기본키에 대해서 이행적으로 종속되지 않아야 한다
        - 즉, 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되지 않아야 한다
        - x -> y, y -> z로 x -> z를 추론할 수 있으면 안된다

        3.1.4. BCNF(Boyce-Codd) 정규형
        - 여러 후보 키가 존재하는 릴레이션에 해당하는 정규화 내용
        - 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3정규형을 보완하는데 의의가 있다
        - 각 정규형은 선행 정규형보다 더 엄격한 조건을 갖는다
            - 모든 제 2정규형 릴레이션은 제 1정규형을 갖는다
            - 모든 제 3정규형 릴레이션은 제 2정규형을 갖는다
            - 모든 BNCF 정규형 릴레이션은 제 3정규형을 갖는다
        - 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF 혹은 BCNF를 갖게 하는 것이다

    3.2. 장점
    - 각종 이상 현상을 해결할 수 있다
    - 데이터베이스 구조 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다
    - 이는 데이터베이스와 연동된 응용 프로그램의 최소한의 영향만 미치며 응용프로그램의 생명을 연장한다
    - 테이블간의 관계는 현실 세계에서 개념들과 그들간의 관계를 반영한다

    3.3. 단점
    - 릴레이션의 분해로 인해 릴레이션 간 연산(JOIN 연산)이 많아진다
    
    3.4. 단점을 보완하기 위한 반정규화
    - JOIN이 많이 발생하여 성능저하가 나타나는 경우 반정규화를 적용해야 한다
    - 반정규화(De-normalization, 비정규화)
        - 중복 통합, 분리 등을 수행하여 정규화된 데이터 관계들을 단순화시키는 기법 중 하나
        - 디스크 I/O량이 많아서 조회 성능이 떨어지거나, 테이블끼리 경로가 너무 멀어 조인의 성능이 저하되거나 칼럼을 계산하여 성능 저하가 예상될 경우 적용한다
        - 일반적으로 조회에 대한 처리 성능이 중요해지면 반정규화를 고려한다
    - 반정규화의 대상
        - 자주 사용되는 테이블에 엑세스하는 프로세스의 수가 가장 많고 항상 일정 범위만 조회하는 경우
        - 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우 또는 성능 이슈가 있는 경우
        - 테이블에 지나치게 많은 조인을 사용해 데이터 조회가 기술적으로 어려운 경우
    - 반정규화를 과도하게 사용하면 데이터의 무결성이 깨지거나 입력, 수정, 삭제에 대한 응답이 늦어질 수 있음에 유의해야 한다


4. Transaction
- 트랜잭션은 작업의 완전성을 보장해주는 것
- 즉, 논리적인 작업을 모두 완벽하게 처리하거나 처리하지 못할 경우 원 상태로 복구하는 기능이다
- 사용자에겐 작업의 논리적 단위, 시스템의 입장에선 데이터들을 접근, 변경하는 프로그램의 단위가 된다

    4.1. 트랜잭션과 Lock
    - 잠금과 트랜잭션은 비슷하나 다르다
    - 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다
    - 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다
    - 이에 반해 트랜잭션은 꼭 여러 개의 변경 작업만 해당하지 않으며 개수에 상관없이 논리적인 작업이 100% 적용되거나 아무것도 적용되지 않음을 보장하는 것이다

    4.2. 트랜잭션의 특성
    - 트랜잭션은 ACID라는 4가지 특성을 만족해야 한다

        4.2.1. 원자성(Atomicity)
        - 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다

        4.2.2. 일관성(Consistency)
        - 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다
        
        4.2.3. 고립성(Isolation)
        - 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다

        4.2.4. 지속성(Durability)
        - 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다

    4.3. 트랜잭션의 상태
    - Active: 트랜잭션의 활동 상태, 트랜잭션이 실행 중이며 동작중인 상태를 말한다
    - Failed: 트랜잭션 실패 상태, 트랜잭션이 더이상 정상적으로 진행할 수 없는 상태
    - Partially Committed: 트랜잭션의 commit 명령이 도착한 상태, 트랜잭션의 commit 이전 sql문이 수행되고 commit만 남은 상태
    - Committed: 트랜잭션 완료 상태, 트랜잭션이 정상적으로 완료된 상태
    - Aborted: 트랜잭션 취소 상태, 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태

    4.4. 트랜잭션을 사용할 때 주의할 점
    - 꼭 필요한 최소의 코드에만 적용하는 것이 좋다, 범위를 최소화할 것
    - 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다
      이것이 계속되면 어느 순간 커넥션을 가져가기 위해 기다려야 하는 상황이 생기게 된다
    
    4.5. 교착상태
    - 두 개 이상의 트랜잭션이 특정 테이블이나 행의 잠금을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하는 상태
    - 이 상태는 아무리 기다려도 상황이 바뀌지 않는다
    - 교착상태의 빈도를 낮추는 방법
        - 트랜잭션을 자주 커밋한다
        - 정해진 순서로 테이블에 접근한다, 여러 트랜잭션이 같은 테이블 순으로 접근하도록 한다
        - 읽기 잠금 획득(SELECT ~ FOR UPDATE)의 사용을 피한다
        - 한 테이블의 복수행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다
          이떄 테이블 단위의 잠금을 획득해 갱신을 직렬화하면 동시성은 떨어지지만 교착상태를 피할 수 있다


5. Statement vs PrepareStatement
- Statement에는 보통 변수를 설정하고 바인딩하는 static sql이 사용되고 PrepareStatement에서는 쿼리 자체에 조건이 들어가는 dynamic sql이 사용된다
- PrepareStatement가 쿼리를 수행하기 전에 이미 쿼리가 컴파일 되어 있으며 반복 수행의 경우 프리 컴파일된 쿼리를 통해 수행이 이루어지기에 빠른 것은 맞다
  그러나 dynamic sql을 사용하는데 따르는 퍼포먼스 저하를 고려해야 한다

- 허나 성능을 고려할 때 시간 부분에서 가장 큰 비중을 차지하는 것은 테이블에사 row를 가져오는 과정이고 sql문을 파싱하는 시간은 이 시간의 1/10에 불과하다
- 그렇기에 sql injection 등의 문제를 보완해주는 PrepareStatement를 사용하는 것이 옳다


6. NoSQL
- 관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조화하는데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소
- 종류마다 쓰기/읽기 성능 특화, 2차 인덱스 지원, 오토 샤딩 지원 등 고유한 특징을 가진다
- 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용한다
- 동적인 스케일 아웃을 지원하기도 하며 가용성을 위하여 데이터 복제 등의 방법으로 관계형 데이터베이스가 제공하지 못하는 성능과 특징을 제공한다

    6.1. CAP 이론
        6.1.1. 일관성(Consistency)
        - 동시성 또는 동일성이라고도 하며 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것
        - 관계형 데이터베이스가 지원하는 가장 기본적 기능이나 일관성을 지원하지 않는 NoSQL에선 데이터 일관성이 느슨하게 처리되어 동일한 데이터가 나타나지 않을 수 있다

        - 일관성을 지키기 위해 두 가지 방법을 사용한다
            - 첫째로 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법 
                - 그만큼 느린 응답이지만 정확성은 보장한다
            - 둘째로 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 후, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 비동기식 방법
                - 빠르지만 쓰기 노드에 장애가 발생했을 때, 데이터 손실이 될 수 있다
        
        6.1.2. 가용성(Availability)
        - 모든 클라이언트의 읽기/쓰기 요청에 대해 항상 응답이 가능해야 함을 보증하는 것, 내고장성이라고도 한다
        - 내고장성을 가진 NoSQL은 클러스터 내에 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능하다
        - 몇몇 NoSQL은 가용성을 보장하기 위해 데이터 복제를 사용한다. 몇 개의 노드가 고장나도 데이터가 유실되지 않게 하는 방법이다
        - 중복 저장 방법에는 두 가지가 있다
            - Master-Slave 복제 방법: 동일한 데이터를 가진 저장소를 하나 더 생성
            - Peer-to-Peer 복제 방법: 데이터 단위로 중복 저장
        
        6.1.3. 네트워크 분할 허용성(Partition tolerance)
        - 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 유실이 일어나더라도 각 지역 내 시스템은 정상 동작해야함을 의미

    6.2. 저장 방식에 따른 NoSQL 분류
        6.2.1. Key-Value Model
        - 가장 기본적 형태의 NoSQL
        - 키 하나로 데이터 하나를 저장하고 조회하는 단일 키-값 구조를 갖는다
        - 단순한 저장구조로 인해 복잡한 조회 연산을 지원하지 않는다
        - 고속 읽기와 쓰기에 최적화된 경우가 많다
        - 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가하여 데이터 정합성을 보장할 수 없다
        - 예시) 프로필 정보, 웹 서버 클러스터를 위한 세션 정보, 장바구니 정보 등

        6.2.2. Document Model
        - 키-값 모델을 개념적으로 확대한 구조로 하나의 키에 하나의 구조화된 문서를 저장하고 조회한다
        - 논리적인 데이터 저장과 조회 방법이 관계형 데이터베이스와 유사
        - 키는 문서에 대한 ID로 표현되며 문서 ID에 대한 인덱스도 생성된다

        - 대부분 NoSQL은 B트리 인덱스를 사용하여 2차 인덱스를 생성한다 
        - B트리는 크기가 커질수록 새로운 데이터를 입력, 삭제할 때 성능이 떨어진다
        - 그렇기에 읽기와 쓰기의 비율이 7:3정도일 때 가장 좋은 성능을 보인다
        - 예시) 중앙 집중식 로그 저장, 타임라인 저장, 통계 정보 저장 등에 사용

        6.2.3. Column Model
        - 하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다
        - 모든 컬럼은 항상 타임 스탬프 값과 함께 저장된다
        - 저장의 기본 단위는 컬럼으로 컬럼의 이름, 값, 타임스탬프로 구성된다
        - 이러한 컬럼의 집합이 row이며 row key는 각 로우를 유일하게 식별하는 값이다
        - 이러한 row들의 집합은 key space가 된다

        - 대부분의 컬럼 모델은 쓰기와 읽기 중 쓰기에 더 특화되어 있다
        - 데이터를 먼저 커밋로그와 메모리에 저장한 후, 응답하기에 빠른 응답속도를 제공한다
        - 그렇기에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보여준다
        - 예시) 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등