1. 개요
- 연결 데이터를 저장할 수 있는 자료 구조
- 예시) 위치 데이터, 사회 연결망, 통신, 생물 등

2. 기본 개념(무방향 그래프 기준)
- 엣지: 두 데이터의 연결(쌍방향, 데이터 순서 상관 없음)
- 인접: 두 데이터가 연결되어 있을 때 인접했다고 이야기함
- 경로: 인접하지 않은 데이터로 이동할 때 거처가야 할 데이터들 (거리는 엣지의 개수)
    최단 경로: 가장 짧은 경로
    싸이클: 특정 노드에서 시작해서 다시 특정 노드로 돌아오는 것
- 차수: 인접한 데이터의 개수

3. 방향 그래프
- 엣지가 하나의 방향을 가질 때 (예시. 인스타그램 팔로우)
- 방향 그래프는 (나가는 데이터, 들어가는 데이터) 순으로 적어야 한다
- 경로: 방향에 맞춰서만 이동 가능
- 차수: 들어오는 입력 차수와 나가는 출력 차수를 나누어 생각해야 한다

4. 가중치 그래프
- 데이터 간의 경로가 무조건 1이 아니라 적절한 가중치를 넣어줌(예시. 인천 - 도쿄: 2, 인천 - 뉴욕: 13)
- 거리: 지나가는 가중치의 합

5. 구현
    5.1 노드
    - '2. 그래프 노드.py' 참고
        5.1.1 리스트
        - 각각의 인덱스를 가진다
        - 인덱스를 알고 있으면 O(1)로 접근 가능

        5.1.2 딕셔너리
        - 키와 값을 가져 직관적으로 접근 가능
        - 역시 O(1)로 효율적
        - 그러나 중복된 값을 저장하지 못한다
        - SNS 등 중복된 값이 많은 곳에서 치명적

    5.2 엣지
        5.2.1 인접 행렬
        - 인접: 두 노드가 연결되어있다
        - 행렬: 리스트 안에 리스트가 있는 것
        - 각 노드를 리스트에 저장해 고유 정수 인덱스를 준다
        - 노드 수 x 노드 수 크기의 행렬을 만든다
        - 노드들의 엣지 유무 및 가중치에 따라 행렬의 요소를 채운다

        5.2.2 인접 리스트
        - 리스트: 순서 정보를 저장하는 자료형
        - 각 노드의 엣지를 리스트에 저장하는 방법

6. 복잡도
- V(vertex): 그래프 안에 있는 모든 노드들의 집합
- E(edge): 그래프 안에 있는 모든 엣지들의 집합
- 노드 수가 V일 때 E는 최대 V ** 2 / 2 (무방향 그래프), 혹은 V ** 2 (방향 그래프)를 가진다
- 즉, E는 V ** 2과 비례

    6.1 노드를 저장하는 공간
    - V개의 노드를 저장
    - O(V)의 공간 사용

    6.2 인접 행렬이 차지하는 공간
    - V x V 의 행렬을 만듬
    - O(V ** 2)의 공간 사용

    6.3 인접 리스트가 차지하는 공간
    - 모든 노드는 하나의 인접 리스트를 가짐: O(V)
    - 저장하는데 무방향 그래프는 2E, 방향 그래프는 E(무방향은 똑같은 엣지를 2개 저장하므로)
      -> O(E)
    - E와 V 중 무엇이 더 크다고 장담할 수 없기에 O(E + V)
    - E의 최악의 경우 O(V ** 2)이지만 주로 O(E + V)를 사용

    6.4 두 노드가 연결됐는지 확인하는 데 걸리는 시간
    - 인접 행렬은 O(1): 인덱스로 바로 접근 가능
    - 인접 리스트는 O(V): 최악의 경우 모두 확인해야 함

    6.5 한 노드에 연결된 모든 노드들을 알아내는데 걸리는 시간
    - 인접행렬: 리스트를 다 돌아야지만 연결된 다른 노드들을 불러올 수 있다
      -> O(V)
    - 인접리스트: 각 노드가 자신과 인접한 노드들에 대한 레퍼런스만 가지고 있음
      -> 최악은 O(V)이나 대부분 이보다 빠르게 실행

