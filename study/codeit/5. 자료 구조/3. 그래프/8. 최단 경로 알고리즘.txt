1. 최단 경로
- 두 노드 사이 경로 중 가장 거리가 짧은 경로

2. 최단 경로 알고리즘
- BFS(비가중치 그래프에서만 가능)
- Dijkstra(가중치 그래프에서도 가능)

3. 최단 경로용 BFS
    3.1 BFS predecessor
    - 원래 BFS는 visited가 있다
    - 이에 추가로 predecessor를 추가한다
    - predecessor: 특정 노드를 오기 직전의 노드

    3.2 최단 경로용 BFS 알고리즘
    - 시작 노드를 방문 표시 후, 큐에 넣음
    - 큐에 아무 노드가 없을 때까지
        - 큐 가장 앞 노드를 꺼낸다
        - 꺼낸 노드에 인접한 노드들을 모두 보면서
            - 처음 방문한 노드면
                - 방문한 노드 표시를 해준다
                - predecessor 변수를 큐에서 꺼낸 노드로 설정
                - 큐에 넣어준다
    
    3.3 Backtracking 알고리즘
    - 현재 노드를 경로에 추가한다
    - 현재 노드의 predecessor로 간다
    - predecessor가 없을 때까지 위 단계를 반복

    3.4 BFS로 찾은 경로가 최단 경로인 이유
    - 거리가 가까운 노드부터 먼 순서대로 방문
    - 그렇기에 특정 노드를 처음 방문한 순간이 최단 경로가 된다

4. Dijkstra
    4.1 변수
        4.1.1 distance
        - 특정 노드까지의 "최단 거리 예상치"
        - 최단 거리 예상치: 현재까지 알고 있는 정보에서 최단 거리

        4.1.2 predecessor
        - 현재까지 최단 경로에서 바로 직전의 노드

        4.1.3 complete
        - 노드까지의 확실한 최단 경로를 찾았다고 표시하기 위한 변수
        - 확실한 최단 경로를 찾았을 때, True
    
    4.2 엣지 Relaxation
    - A에서 B를 방문하면서, B의 distance, predecessor을 바꾸는 것을 엣지 (A, B)를 relax한다고 이야기함
    - 찾은 값이 원래 값보다 더 작을 경우 바꿔주는 것을 Relaxation한다고 함

    4.3 알고리즘
    - 시작점 distance를 0으로, predecessor를 None으로
    - 모든 노드가 complete 일 때까지
        - complete하지 않은 노드 중 distance가 가장 작은 노드 선택
        - 이 노드에 인접한 노드 중 complete하지 않은 노드를 돌면서
            - 각 엣지를 relax한다
        - 현재 노드를 complete 처리한다

    4.4 Dijkstra로 찾은 경로가 최단 경로인 이유
    - Dijkstra 알고리즘은 반복문을 돌면서 최단 경로를 이미 찾은 노드를 하나씩 찾아준다
        - 처음에는 시작 노드의 최단 경로를 확정 지었고, 그 다음에는 다음 노드의 최단 경로를 확정
    - 그리고 최단 경로를 이미 찾은 노드의 엣지들을 모두 relax 해줬다
        - 최단 경로는 다른 노드들까지의 최단 경로 + 현재 노드기 때문에, 이미 확정난 최단 경로들로 다른 노드들까지의 최단 거리 예상치를 구하는 것
    - 매 단계에서 이 distance가 가장 작은 노드는 최단 거리를 이미 찾았다고 확신할 수 있다
    