1. 개요
- 앞 노드와 뒷 노드를 모두 갖는다.
- 즉,  data, next와 함께 prev를 갖는다.
- 전체적으로 '7. 더블리 링크드 리스트.py'와 '3. 링크드 리스트.txt'를 참고


2. 시간 복잡도
    2.1 접근/탐색 연산
    - 싱글리 링크드 리스트와 동일
    - O(n)

    2.2 삽입/삭제 연산
    - 경우는 많으나 특정 노드가 주어지면 길이와 상관없이 일정하게 처리 가능
    - O(1)

    2.3 현실적인 시간 복잡도
    - 접근/탐색은 동일
    - 삽입과 삭제는 원하는 노드에 접근이나 탐색을 해야하므로 결국 O(n + 1)

    2.4 삽입/삭제 연산이 특수한 경우
    - head/tail 노드를 삽입하거나 지울 때, next와 prev 속성을 모두 갖고 있기에 모두 O(1 + 1)
    - 즉, O(1)
    - 이는 prev 속성이 없어서 tail 노드를 삭제할 때, 
      전 위치의 노드를 받아 삭제해야 했던(즉, O(n + 1))이 걸린 싱글리 링크드 리스트보다 효율적


3. 싱글리 링크드 리스트와의 차이점
    3.1 속성/접근의 차이
    - next 속성만 가짐 vs next와 prev 속성 모두를 가짐
    - 특정 노드 앞에 있는 노드에 접근 불가 vs 어떤 노드던지 링크드 리스트 안 모든 노드에 접근 가능

    3.2 추가적 공간(레퍼런스를 저장하는 공간)의 차이
        3.2.1 싱글리 링크드 리스트
        - next 속성만 있고 tail 노드엔 저장된 레퍼런스가 없음
        - 싱글리 링크드 리스트 안에 레퍼런스 개수는 n - 1개
        - O(n)

        3.2.2 더블리 링크드 리스트
        - prev와 next 속성이 있음
        - 더블리 링크드 리스트 안에 레퍼런스 개수는 2n - 2개
        - O(n)이지만 실제론 싱글리 링크드 리스트보다 2배 정도 느림

