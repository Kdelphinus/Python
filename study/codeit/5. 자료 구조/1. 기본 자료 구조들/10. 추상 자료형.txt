1. 기능 vs 구현
- 기능: 연산이 "무엇"을 하는지
- 구현: 기능을 "어떻게" 하는지

    1.1 삽입 연산의 기능과 구현
    - 기능: 순서 데이터에서 원하는 위치에 데이터를 저장
    - 구현: 링크드 리스트의 구동 방식, 동적 배열의 구동 방식 등 어떤 것을 이용했는지에 따라 다름

2. 추상 자료형
- 추상화: 구현을 몰라도 기능만 알면 함수를 사용할 수 있도록 만드는 것
- 추상 자료형: 자료 구조를 추상화 한 것, 데이터를 저장/사용할 때 기능만 생각

    2.1 자료 구조
        2.1.1 리스트 개요
        - 데이터간 순서 관계를 유지할 수 있다
        - 접근 연산: 특정 위치에 있는 데이터를 가지고 오거나 수정한다
        - 탐색 연산: 특정 조건을 만족하는 데이터를 찾는다
        - 삽입 연산: 특정 위치에 새로운 데이터를 저장한다
        - 삭제 연산: 특정 위치에 있는 데이터를 지운다

        2.1.2 동적 배열
        - 데이터를 메모리에 순서대로 그리고 연속적으로 저장한다
        - 접근 연산: 인덱스 주소를 한 번에 계산하여 메모리에 접근한다
        - 탐색 연산: 가장 앞 인덱스부터 선형적으로 모든 데이터를 확인한다
        - 삽입 연산: 인덱스 뒤 데이터를 한 칸씩 뒤로 밀고, 데이터를 저장한다
        - 삭제 연산: 데이터를 지우고 뒤 인덱스들을 하나씩 앞으로 옮겨서 저장한다
        - 동적 배열로 리스트를 구현할 수 있다
        
        2.1.3 링크드 리스트
        - 접근, 탐색, 삽입, 삭제 연산이 가능
        - 링크드 리스트로 리스트 구현 가능

        2.1.4 결론
        - 자료 구조는 기능과 구현이 모두 들어가 있다
    
    2.2 추상 자료형
    - '데이터를 메모리에 순서대로 저장하고 바꾸고 싶다'는 기능만 생각
    - 구현을 생각하지 않으므로 동적 배열, 링크드 리스트의 구현 과정을 생략하고 리스트라는 기능만을 먼저 생각하게 됨
    - 코드의 전반적인 흐름을 파악할 수 있음

    2.3 핸드폰을 통한 예시
    - 핸드폰은 전화를 걸고 받고 메시지를 보내고 받을 수 있으며 어디든 들고 다닐 수 있다
    - 추상 자료형으로써 핸드폰
      이때 우리는 핸드폰이 어떻게 전화를 걸고 받는지에 대한 구현을 생각하지 않고 긴으만을 바라보며 핸드폰을 이야기한다
      그렇기에 핸드폰은 추상 자료형이다
    - 자료 구조
      핸드폰의 모델에 따라 다른 구현 방식을 통해 전화를 걸고 받는다
    
    2.4 리스트
    - 즉, 리스트라는 기능을 생각하는 것은 추상 자료형, 동적 배열과 링크드 리스트 등 구현까지 구체적으로 생각하는 것이 자료 구조이다

    2.5 결론
    - 기능, 흐름을 중점적으로 생각할 땐 추상 자료형
    - 코드의 성능을 분석하거나 최적화 시켜야 할 때는 자료 구조를 중점적으로

    2.6 파이썬
    - 추상화가 많이 된 고수준 언어
    - 많은 자료형 이름이 추상 자료형
    - 파이썬에서 list -> 구현을 몰라도 기능만 알면 사용 가능

3. 리스트 (더욱 구체적으로)
- 데이터간 순서 관계를 유지할 수 있다
- 접근 연산: print(list_name[index]), list_name[index] = value
- 탐색 연산: 'value' in list_name -> True or False
- 삽입 연산: list_name.insert(index, value)
- 삭제 연산: del list_name[index]

    3.1 구현 방식 선택
    - 접근을 많이 하고 싶다면 동적 배열
    - 맨 앞에 데이터를 계속 삽입하고 싶다면 더블리 링크드 리스트
    - 시간 복잡도는 '2.배열.txt'과 '6.더블리 링크드 리스트.txt' 참고
    - 참고로 파이썬 리스트는 동적 배열로 구현되어 있음

4. 큐(Queue)
- 맨 앞만 삭제하고 맨 뒤만 추가하는 리스트(FIFO: first-in-first-out)
- 마트 대기줄을 생각하면 됨

    4.1 개요
    - 데이터간 순서 관계를 유지할 수 있다
    - 맨 뒤 데이터 추가
    - 맨 앞 데이터 삭제
    - 맨 앞 데이터 접근

    4.2 deque (파이썬)
    - Doubly-ended-queue의 약자
    - 맨 앞과 뒤에 데이터를 삽입하고 삭제할 수 있게 해주는 자료형
    - '11. deque(queue).py' 참고

    4.3 queue 구현
    - 맨 앞 삭제, 맨 뒤 삽입, 맨 앞 접근의 기능만 있으면 됨
    - 동적 배열은 순서대로 O(n), O(1), O(1)
    - 더블리 링크드 리스트는 O(1), O(1), O(1)
    - 즉, 더블리 링크드 리스트가 더욱 효율적
    - 실제 파이썬에서 deque도 더블리 링크드 리스트로 구현되어 있음

5. 스택(stack)
- 차곡차곡 쌓여있는 구조
- 가장 마지막에 들어온 데이터가 가장 먼저 삭제된다(LIFO: last-in-first-out)
- 워드 작업 중, ctrl + z 등의 기능에서 사용 가능

    5.1 개요
    - 데이터간 순서 관계를 유지할 수 있다
    - 맨 뒤 데이터 추가
    - 맨 뒤 데이터 삭제
    - 맨 뒤 데이터 접근

    5.2 deque를 사용하여 stack을 표현
    - 맨 앞과 맨 뒤의 데이터를 삽입하고 삭제할 수 있기에 스택으로도 사용 가능
    - '13. deque(stack).py'를 참고

    5.3 stack 구현
    - 맨 뒤 삭제, 맨 뒤 삽입, 맨 앞 접근 기능만 가짐
    - 동적 배열은 순서대로 O(1), O(1), O(1)
    - 더블리 링크드 리스트는 O(1), O(1), O(1)
    - 둘 중 아무구조나 사용해도 상관없음
    - 파이썬에서 deque는 더블리 링크드 리스트로 구현되어 있음
    - 그러나 파이썬에서 list(동적 배열)로 사용해도 똑같이 효율적
    - '13. deque(stack).py'에서 deque대신 list를 써도 똑같다

6. 딕셔너리
- 혹은 맵이라고 부름

    6.1 개요
    - 데이터간 순서 관계를 약속하지 않음
    - key-value 데이터 쌍 삽입
    - key를 이용한 데이터 탐색
    - key를 이용한 데이터 삭제
    - '15. dictionary.py'를 참고

    6.2 딕셔너리 구현
    - 해시 테이블로 구현이 가능하다
    - key-value 쌍 삽입, key를 이용한 탐색, key를 이용한 삭제가 모두 O(1)로 효율적이기도 하다
    - 파이썬은 해시 테이블로 딕셔너리를 구현

7. 세트
    7.1 개요
    - 데이터간 순서 관계를 약속하지 않음
    - 삽입: 데이터를 저장할 수 있다 (중복 데이터는 안 됨)
    - 탐색: 데이터가 저장됐는지 확인할 수 있다
    - 삭제: 저장한 데이터를 지울 수 있다
    - '16. set.py' 참고

    7.2 세트 구현
    - 보통 해시 테이블을 사용하여 구현
    - 인덱스에 key만 저장
    - 삽입, 탐색, 삭제가 모두 O(1) (해시 테이블을 사용하므로)
    - 파이썬은 해시 테이블로 세트 구현