1. 링크드 리스트(연결 리스트)
    1.1 개요
    - 데이터를 순서대로 저장
    - 요소를 계속 추가할 수 있음

    1.2 실행방식
    - 노드라는 단위에 데이터를 저장하고 각 노드들을 순서대로 연결하여 저장한 데이터
    - 노드 안에 한 쪽은 값, 다른 한 쪽은 다음에 올 노드를 저장(마지막 노드는 값만 저장)

    1.3 노드
    - 노드는 data와 next 속성을 가진다.
    - data는 값을, next에는 다음 노드를 가진다.
    - 첫 노드를 head 노드라고 한다. 즉, head 노드만 있으면 흩어져 있는 노드들도 순서대로 살필 수 있다.
    - '4. 노드 클래스.py' 참고


2. 접근
    2.1 개요
    - '5. 링크드 클래스.py' 참고

    2.2 시간 복잡도
    - 인덱스 x에 있는 노드에 접근하려면 head에서 다음 노드로 x번 가야함
    - 마지막 노드에 접근하려면 head에서 다음 노드로 n - 1번 가야됨
    - 즉, 링크드 리스트 접근 시간 복잡도는 O(n)


3. 삽입 연산
    3.1 마지막 순서에 삽입할 때
    - append 함수와 동일한 방법

    3.2 중간 순서에 삽입할 때
    - 새로운 노드의 next 속성을 이전 노드의 next 속성으로 바꿈
    - 이전 노드의 next 속성을 새로운 노드로 지정

4. 그 외 연산들
- '5. 링크드 리스트.py' 참고

5. 링크드 리스트 시간 복잡도
    5.1 접근
    - 2.2 참고

    5.2 탐색
    - 선형 탐색과 동일
    - O(n)

    5.3 삽입/삭제
    - 삭제할 주변 인덱스의 레퍼런스만 수정
    - 즉, 어떤 노드든, 리스트의 길이에 상관없이 시간은 일정
    - O(1)

    5.4 현실적인 삽입/삭제 시간 복잡도
    - 삽입/삭제를 위해선 previous_node를 찾아야 함
    - 결국 접근과 탐색이 병행되어야 함
    - O(n + 1) -> O(n)

    5.5 head/tail 노드와 관련있는 경우
    - head/tail 노드는 저장되있기에 항상 바로 찾을 수 있음
    - 즉, head/tail과 관련된 삽입/삭제는 O(1)
    - 그러나 tail 노드를 삭제할 땐, tail 노드 바로 앞의 노드를 찾아야 하므로 O(n)

    