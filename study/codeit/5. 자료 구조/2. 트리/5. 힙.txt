1. 힙의 조건
- 형태 속성: 힙은 완전 이진 트리다
- 힙 속성: 모든 노드의 데이터는 자식 노드들의 데이터보다 크거나 같다

2. 정렬
- 정렬 알고리즘: 데이터를 재배치하는 구체적인 방법
- 삽입 정렬, 퀵 정렬, 선택 정렬, 합병 정렬 등 많은 방법이 있음
- 힙을 사용해서도 정렬이 가능(힙 정렬)

3. 힙 구현
- 완전 이진 트리는 동적 배열로 구현 가능('3. 완전 이진 트리.py' 참고)
- '4. heapify.py'는 완전 이진 트리를 힙으로 정렬시키는 프로그램
- 시간 복잡도는 O(lg(n))이다 (루트가 리프까지 내려가는게 최악이고 높이는 lg(n)이기 때문)

    3.1 모든 노드에 heapify를 할 때 (순서는 가장 마지막 노드부터)
    - leaf 노드는 모두 힙 속성을 지키고 있다고 할 수 있다
    - 그렇게 밑에서부터 올라가면 힙 속성을 체크하는 노드 밑의 부분은 모두 힙 속성을 지키고 있음을 알 수 있다
    - 그렇기에 heapify를 모든 노드에 호출하면 힙을 구현할 수 있다
    - 그렇기에 힙을 구현하는 시간 복잡도는 O(nlg(n))이다

4. 힙 정렬
- 힙 속성을 가진 트리의 루트 노드와 가장 마지막 노드를 바꾼 뒤, 
- 가장 마지막 노드는 트리에서 연결을 끊는다
- 그리고 heapify를 진행한다
- 위 세가지 순서를 반복하면 결국 오름차순으로 정렬된다
- 내림차순을 하고 싶으면 힙 속성을 반대로 적용하면 된다

    4.1 시간 복잡도
    - 리스트를 힙으로 만든다: O(nlg(n))
    - root 노드와 마지막 노드의 위치를 바꾼다: O(1)
    - 새로운 root 노드가 힙 속성을 지키도록 heapify를 한다: O(lg(n))
    - 2 ~ 3을 반복: 즉 2와 3을 합쳐 O(nlg(n))이 됨
    - 결국 O(nlg(n)) + O(nlg(n))이므로 총 O(nlg(n))이다

    4.2 다른 정렬 알고리즘과 비교
    - 선택 정렬: O(n ** 2)
    - 삽입 정렬: O(n ** 2)
    - 합병 정렬: O(nlg(n))
    - 퀵 정렬: 평균 O(nlg(n)) (최악 O(n ** 2))
    - 힙 정렬: O(nlg(n))

5. 우선순위 큐
    5.1 기능
    - 데이터를 저장할 수 있다
    - 저장한 데이터가 우선순위 순서대로 나온다

    5.2 힙으로 구현
        5.2.1 힙에 데이터 삽입
        - 삽입하고 싶은 데이터를 가장 마지막 인덱스에 삽입
        - 삽입한 데이터와 부모 노드의 데이터를 비교하며 힙의 속성을 지킬 때까지 반복
        - '8. 우선순위 큐.py' 참고

        5.2.2 힙에서 최고 우선순위 데이터 추출하기
        - 우선순위는 지정하기 나름(여기선 가장 큰 데이터로 가정)
        - 루트 노드와 마지막 노드를 서로 바꾼다
        - 마지막 노드의 데이터를 변수에 저장해 준다
        - 마지막 노드를 삭제한다
        - root 노드에 heapify를 호출해서 망가진 힙 속성을 고친다
        - 변수에 저장한 데이터를 리턴한다
        - '8. 우선순위 큐.py' 참고
    
    5.3 시간 복잡도
        5.3.1 삽입
        - 힙의 마지막 인덱스에 노드를 삽입: O(1)
        - 삽입한 노드와 부모 노드 비교: O(1), 삽입된 데이터가 더 크면 위치 변경: O(1)
        - 2단계 반복: O(lg(n)) (높이가 O(lg(n))이므로)
        - 즉, O(lg(n))

        5.3.2 추출
        - root 노드와 마지막 노드를 바꾼다: O(1)
        - 마지막 위치로 간 원래 root 노드의 데이터를 별도 변수에 저장하고 삭제: O(1 + 1) = O(1)
        - 새로운 root 노드를 대상으로 heapify를 호출하여 힙 복원: O(lg(n))
        - 변수 리턴: O(1)
        - 즉, O(lg(n))

    5.4 우선순위 큐를 구현하는 다른 자료 구조들
        5.4.1 정렬된 동적 배열
            5.4.1.1 삽입
            - 이진 탐색으로 삽입할 위치를 찾고: O(lg(n))
            - 그 위치에 데이터를 삽입: O(n)
            - 즉, O(n)

            5.4.1.2 추출
            - 맨 뒤에 있는 데이터를 삭제하고 출력: O(1)
            - 즉, O(1)

        5.4.2 정렬된 더블리 링크드 리스트
            5.4.2.1 삽입
            - 선형 탐색으로 위치를 찾음: O(n)
            - 그 위치에 데이터 삽입: O(1)
            - 즉, O(n)

            5.4.2.2 추출
            - 마지막 데이터 추출
            - 즉, O(1)

        5.4.3 힙
        - 삽입과 추출 모두 O(lg(n))

        5.4.4 결론
        - 삽입은 힙이, 추출은 정렬된 동적 배열이나 정렬된 더블리 링크드 리스트가 효율적
        - 그렇기에 용도에 따라 힙을 구현할 자료 구조를 선택해야 함


