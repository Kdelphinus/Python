1. 개요
- 이진 트리이면서 모든 노드는 왼쪽 노드보다 크고 오른쪽 노드보다 작아야한다
- '10. 이진 탐색 트리.py'를 전체적으로 참고

2. 구현
- 완전 이진 트리가 아니기에 배열이나 리스트로 구현하지 않는다
- Node를 구현한 class에서 parent 노드를 추가
    
    2.1 출력
    - in-order 순회를 사용하면 이진 탐색 트리를 정렬된 순서대로 출력할 수 있다

    2.2 삽입
    - 삽입 이후에도 이진 탐색 트리의 속성이 유지되어야 한다
    - 새로운 노드 생성: O(1)
    - root 노드부터 비교하면서 저장할 위치를 찾음: O(h) (h: 높이)
    - 찾은 위치에 새롭게 만든 노드 연결: O(1)
    - 즉, O(h)

    2.3 탐색
    - 특정 데이터를 갖는 노드를 리턴하는 연산
    - 주어진 노드의 데이터와 탐색하려는 데이터 비교
    - 탐색하려는 데이터가 더 크면 오른쪽으로
    - 더 작으면 왼쪽으로 이동
    - 값을 찾으면 리턴
    - O(h + 1) = O(h)

    2.4 삭제
    - 삭제하려는 데이터를 찾아야 함 (탐색 연산 사용)

        2.4.1 여러가지 경우
            2.4.1.1 삭제하려는 데이터가 leaf 노드의 데이터일 때
            - 지우려는 노드가 부모 노드의 왼쪽이면 왼쪽 자식을 None으로 오른쪽이면 오른쪽을 None으로 지정

            2.4.1.2 삭제하려는 노드가 하나의 자식 노드만 있을 때
            - 삭제하려는 노드의 자식 노드의 부모 노드 = 삭제하려는 노드의 부모 노드
            - 삭제하려는 노드의 부모 노드의 자식 노드 = 삭제하려는 노드의 자식 노드

            2.4.1.3 삭제하려는 데이터의 노드가 두 개의 자식이 있을 때
            - 지우려는 노드의 오른쪽 노드로 가서 find_min을 찾는다(find_min은 '10.이진 탐색 트리.py'참고)
            - 특정 노드보다 큰 노드 중 가장 작은 노드(여기서 find_min으로 찾은 노드)를 successor라고 한다
            - 지우려는 노드의 데이터를 찾은 노드의 데이터로 바꾼다
            - 찾은 노드를 지운다
            - successor는 leaf 노드이거나 오른쪽 자식만 가지고 있다
        
        2.4.2 시간 복잡도
        - 삭제에 탐색은 필요하므로 O(h)는 기본으로 들어간다
            2.4.2.1 지우려는 노드가 leaf 노드일 때
            - leaf 노드의 부모에서 자식 레퍼런스를 None으로 지정하기에 O(1)

            2.4.2.2 지우려는 노드가 하나의 자식이 있을 때
            - 노드에 상관없이 레퍼런스 두 개를 지정하면 되기에 O(1)

            2.4.2.3 지우려는 노드가 두 개의 자식이 있을 때
            - successor를 찾는 과정: O(h)
            - 지우려는 노드에 데이터를 저장: O(h) (지우려는 노드에 접근해야 하므로)
            - 경우 1 또는 경우 2의 경우로 삭제: O(1)
            - 즉, O(h)

            2.4.2.4 결론
            - 모든 삭제 과정은 O(h)의 시간 복잡도를 갖는다

3. 높이(h)
- 이진 탐색의 기본적인 연산들(탐색, 삽입, 삭제)의 시간복잡도는 모두 O(h)
- 즉, h가 작을수록 효율적
- 완전 이진 트리의 경우 항상 높이가 O(lg(n))지만 그런 경우는 많지 않다
- 최악의 경우 높이는 O(n)이 될수도 있다(한쪽으로 치우쳤을 때)
- 그와 반대로 높이가 O(lg(n))에 가까울수록 균형잡혔다고 이야기함
- 평균적으론 O(lg(n))의 시간복잡도를 가지나 최악의 경우O(n)을 가질 수 있음
- 그리고 실제로 생각보다 균형을 잃기 쉽다
- 그렇기에 보통 h를 시간복잡도로 표기한다

4. 이진 탐색 트리를 활용한 딕셔너리
- '11. 이진 탐색 트리 노드(딕셔너리).py' 참고
- 시간 복잡도는 위와 동일하다

5. 이진 탐색 트리와 해시 테이블
- 시간 복잡도를 비교할 때, 해시 테이블이 모든 연산에서 효율적
- 그러나 해시 테이블은 데이터 사이의 순서를 저장할 수 없다
- 그렇기에 딕셔너리나 세트의 자료를 정렬된 상태로 사용하고 싶을 때는 이진 탐색 트리를 사용해야 한다