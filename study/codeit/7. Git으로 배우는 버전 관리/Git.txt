I. Git
  1. 개요
  - 코드의 버전을 관리하는 툴
  - 지난 과정을 확인할 수 있고 문제가 생길 때, 지난 버전으로 돌아갈 수 있다

  2. github
  - 작업한 코딩을 백업하는 곳
  - git으로 백업한 코딩을 보관할 수 있는 곳
  - 다른 사람과 협업도 가능

  3. 레포지토리(repository)
  - 버전별 프로젝트 모습이 저장된 것
  - 커밋이 저장되는 곳
  - git을 실행한 후, git init을 입력하면 비어있는 레포지토리 생성
  - 정확하게는 working directory 안에 숨겨진 .git 디렉토리

  4. 커밋(commit)
  - 프로젝트 폴더의 모습을 하나의 버전으로 남기는 것, 그리고 그 결과물
  - 처음 커밋할 때, 누가한 커밋인지 알려줘야 한다
    git config user.name "이름"
    git config user.email "이메일"
  -git commit을 입력하면 커밋 생성하기 전(이는 코드잇 강의의 예시, staging area에 올리는 과정)
    git add "커밋할 프로그램 파일.py"
    git add "라이센스"

      4.1 주의 사항
      - 처음으로 커밋을 하기 전 사용자의 이름과 이메일 주소를 설정
      - 커밋 메세지 남기기(옵션 -m으로, 정보나 설명 등)
      - 커밋할 파일을 git add로 지정
      - tip: README.md는 코드의 설명이 있는 파일

  5. git의 3가지 작업 영역
      5.1 working directory(working tree)
      - 작업을 하는 프로젝트 디렉토리
      - 예시에선 MathTool

      5.2 staging area(index)
      - git add를 한 파일들이 존재하는 영역
      - 커밋을 하게되면 staging area에 있는 파일들만 커밋에 반영

      5.3 repository
      - working directory의 변경 이력들이 저장되어 있는 영역
      - 즉, 커밋들이 저장되는 영역

      5.4 주의 사항
      - 수정을 했더라도 staging area에 올리지 않은 파일들은 새로운 버전을 저장해도 수정되지 않음

  6. git add 더 자세히 보기
  - git status를 입력하면 git의 현재 상태를 출력
  - git status를 칠 때, working tree clean은 커밋할 수정된 파일이 없다는 것
  - changes to be committed는 변경된 사항이 커밋에 반영
  - changes not staged for commit은 변경된 사항이 커밋에 반영되지 않았단 뜻
  - 하위 폴더의 데이터들은 폴더만 추가하면 하위 데이터들도 다 추가됨
  - git add .은 현재 프로젝트 디렉토리 내에서 변경사항이 생긴 모든 파일들을 staging area에 추가하는 의미
  - git reset '파일이름'을 하면 staging area에 올라간 파일을 삭제할 수 있음

  7. git이 보는 파일의 4가지 상태
      7.1 Untracked 상태
      - git에 의해서 변동사항이 전혀 추적되지 않고 있는 상태
      - 파일을 생성하고 한 번도 git add를 해주지 않으면 이 상태

      7.2 Tracked 상태
      - 파일이 git에 의해 추적되고 있는 상태

          7.2.1 Staged 상태
          - 파일 내용이 수정되고나서, staging area에 올라와 있는 상태
          - 새로 생성한 파일에 내용을 쓰고 git add
          - 한 번이라도 커밋에 포함돼었던 파일이라도 내용을 수정하고 git add 해주면 이 상태

          7.2.2 Unmodified 상태
          - 현재 파일의 내용이 최신 커밋의 모습과 비교했을 때, 전혀 바뀐게 없을 때
          - 커밋 직후, working directory 안의 모든 파일은 이 상태

          7.2.3 Modified 상태
          - 최신 커밋의 모습과 비교했을 때, 조금이라도 바뀐 내용이 있는 상태

  8. 그 외 git 커맨드
  - git help '알고 싶은 커맨드의 이름' 또는 man git-'알고 싶은 커맨드의 이름': 커맨드의 도움말 출력


II. Github
  1. 원격 레포지토리
  - 컴퓨터의 레포지토리는 로컬 레포지토리
  - 깃허브의 레포지토리는 원격 레포지토리 혹은 리모트 레포지토리

  - …or create a new repository on the command line
    -> 로컬 레포지토리를 만들고 커밋을 한 후에 깃허브에 업로드하기
    내용을 git bash에 복사하여 실행

  - …or push an existing repository from the command line
    -> 이미 만든 로컬 레포지토리를 깃허브에 업로드 하기
    내용을 git bash에 복사하여 실행

  2. git bash에서 복사 붙여넣기
  - 복사: ctrl + insert
  - 붙여넣기: shift + insert(홈페이지에서 복사한 걸 붙여넣기 할 땐, insert만 눌러야 함)

  3. 로컬 레포지토리에서 수정했을 때
  - git push: 리모트 레포지토리에도 반영
  - 새로운 커밋을 할 때마다 반영해줘야 함

  4. 리모트 레포지토리에서 수정했을 때
  - git pull: 로컬 레포지토리에도 반영

  5. 리모트 레포지토리를 쓰는 이유
  - 안정성: 백업용
  - 협업 가능: github에 올려 공유하여 서로 다른 컴퓨터로도 협업 가능(git push와 git pull을 적극 활용)

  6. git pust
  - 레포지토리를 가져가는 건 공개 범위에 따라 가져갈 수 있지만 push는 아무나 할 수 없다
  - 다른 사용자도 git push를 가능하게 하려면 해당 리모트 레포지토리의 collaborator로 지정해야 한다
    github에서 setting 안 항목에 invite a collaborator가 있음

  7. clone
  - 다른 사람의 레포지토리를 가져올 때, git clone '레포지토리 주소'를 입력
  - 레포지토리 주소는 github 안 레포지토리 설명에 있음

 
III. 커밋 다루기
  1. git log
  - 지금까지 한 커밋의 로그 출력
  - 가장 아래가 가장 오래된 것, 위로 올라갈수록 최신 것

      commit 9884a80bbae8bbfc25d7ff260dc0e91214434b38(커밋 아이디, 커밋 해시) (HEAD -> main, origin/main)
      Author: Kdelphinus <68101516+Kdelphinus@users.noreply.github.com>
      Date:   Thu Apr 15 01:58:55 2021 +0900

          커밋 메세지

  - git log --pretty=oneline: 한 번의 커밋을 한 줄로 표기
  - git show '커밋아이디(전체를 다 칠 필요는 없으며 구분 가능한 수준만, 앞의 4글자 정도)'
    --- 뒤는 커밋 이전 모습
    +++ 뒤는 커밋 후의 모습

  2. git commit
  - -m 옵션을 쓰지 않고 커밋하면 vim이 실행되면서 메세지를 입력할 수 있음

  3. 가장 최신 커밋을 수정하기(커밋을 추가하지 않고)
  - 커밋 직전까지 수행한 뒤, git commit --amend
  - 가장 최신 버전 커밋 메세지가 나오고 그것을 수정하거나 그대로 가져갈 수 있음
  - 커밋 로그를 치면 로그 수는 그대로고 커밋 아이디만 변경된다

  4. 커밋 메시지 가이드라인
  - 커밋 메시지의 제목과 상세 설명 사이에는 한 줄 비워두기(밑에는 MathTool 커밋 메세지 예시)
      Add multiply function(제목)

      calculator.py supports 3 function now(상세설명)
  - 커밋 메시지의 제목 뒤에 .을 붙이지 말 것
  - 커밋 메시지의 제목의 첫 번째 알파벳은 대문자로 할 것
  - 커밋 메시지의 제목은 명령조로 작성할 것(Fix it / Not Fited it or Fixes it)
  - 커밋의 상세 내용에 적을 것
      왜 커밋을 했는가
      어떤 문제가 있었는가
      적용한 해결책이 어떤 효과를 가지는가
  - 다른 사람들이 자신의 코드를 바로 이해할 수 있다고 가정하지 말고 최대한 친절히 작성

  5. 커밋할 때 지킬 가이드라인
  - 하나의 커밋에는 하나의 수정사항, 하나의 이슈를 해결한 내용만 남길 것, 즉 하나의 커밋은 하나의 사실만 남길 것
      이것은 최대한 작은 단위의 변화를 기준으로 커밋하라는 것
      작은 단위는 사람마다 다를 수 있으나 너무 많은 수정을 한 번의 커밋에 담지 말 것
  - 현재 프로젝트 디렉토리의 상태가 그 내부의 전체 코드를 실행했을 때, 에러가 발생하지 않는 상태인 경우에만 커밋할 것
      커밋되는 코드들은 항상 정상 실행되어야 한다

  6. 긴 커맨드 alias하기
  - git config alias.바꿀 명령어 '원래 명령어'
  - 현재 우리 git에서 log --pretty=oneline을 history로 바꿨음

  7. 버전 간 커밋 차이 비교하기
  - git diff 이전커밋이름 최신커밋이름
  - 앞 버전을 앞에, 후 버전을 뒤에 적으면 된다
  - 커밋 이름은 다 적을 필요 없이 특정지을 수 있는 정도만 적으면 된다

  8. HEAD
  - 보통 가장 최근에 한 커밋을 가리킴
  - 매번 더 새로운 커밋을 가리킴
  - working directory의 구성은 HEAD가 가리키는 커밋을 기준으로 구성됨
  - 즉, HEAD가 이전 버전을 가리키고 있으면 working directory는 과거 버전을 기준으로 구성

  9. git reset
  - git reset --hard 커밋아이디
  - 커밋 아이디로 HEAD가 바뀌고 입력한 커밋아이디보다 최신 버전은 사라진다

      9.1 더 깊게 들어가기 전에 staging area의 작동방식 확인
      - 커밋 하기 전 staging area에 올린 파일들은 커밋한다고 사라지지 않음
      - 파일들을 staging area에 그대로 있으면서 새로운 파일은 추가되고 더 새로운 버전으로 교체됨

      9.2 여러 옵션들(working directory / staging area / repository)
      - eea5 커밋으로 리셋했을 때
      - --hard: eea5 커밋처럼 바뀜 / eea5 커밋처럼 바뀜 / 헤드가 eea5 커밋을 가리킴
          eea5 커밋보다 최신 버전의 작업은 사라진다(복구 불가)
      - --mixed: 안 바뀜 / eea5 커밋처럼 바뀜 / 헤드가 eea5 커밋을 가리킴
          working directory는 최신 버전을 그대로 가리킨다
      - --soft: 안 바뀜 / 안 바뀜 / 헤드가 eea5 커밋을 가리킴
          working directory, staging area 모두 최신 버전을 가리킴

      - git history(원래는 git --pretty=oneline)을 통해 repository를 볼 수 있고
      - git status를 통해 staging area를 볼 수 있고
      - cat calculator.py를 통해 working directory가 어느 버전인지 알 수 있음(MathTool 예시) 
      - github에 올라가 있는 최신 버전을 불러와 복구시킬 수도 있다

      9.3 reset할 때, 커밋아이디
      - HEAD^: HEAD 바로 직전 커밋
      - HEAD~2: HEAD 두 번째 전 커밋
      - HEAD~x: HEAD x 번째 전 커밋

  10. git tag
  - git tag 태그이름 커밋아이디: 태그를 달아줄 수 있음
  - git tag: 태그들을 보여줌
  - git show 태그이름: 태그에 연결된 커밋을 보여줌


IV. 브랜치
  1. 개요
  - 하나의 코드 관리 흐름
  - 하나의 프로그램에서 유료와 무료 버전을 만드는 등 
  - git branch: 현재 있는 branch를 확인할 수 있음

  2. 브랜치 생성과 삭제
  - git branch 브랜치이름: 지금까지 만든 코드도 브랜치에 속하게 됨
  - git checkout 가고싶은브랜치: 브랜치로 이동
  - git status로 현재 있는 branch 확인 가능
  - 브랜치에서 수정한 것은 다른 브랜치에는 영향을 끼치지 않는다
  - git branch -d 브랜치이름: 브랜치 삭제
  - git checkout -b 브랜치이름: 브랜치를 만들면서 그 브랜치로 이동

  3. merge하기
  - 무료 버전에만 추가했던 함수가 유료 버전에도 추가되어야 할 때, 유료 버전에서 직접 추가하는 것이 아닌 무료버전을 가져오는 방법
  - 즉 합병하는 것
  - git merge 합칠브랜치: 현재 위치의 브랜치에 합칠브랜치를 합치겠다
  - 머지 커밋: 해드가 가리키던 커밋에 다른 브랜치가 가리키던 커밋을 합쳐서 새로운 커밋을 만드는 작업

    3.1 conflict
    - 머지를 하다 충돌이 발생한 것
    - 그 후, 충돌된 파일을 가면 HEAD와 머지하는 내용을 보여주며 충돌됐다고 알려줌
    - 컨플릭트가 발생한 파일을 열고 머지의 결과가 되었으면 하는 내용을 입력, 그 후 커밋하면 됨
    - 혹은 git merge --abort를 실행하면 merge 자체를 취소해버릴 수도 있다
    - git status를 사용하면 conflict된 항목을 살펴볼 수 있다
    - 여러 개가 conflict가 났을 때, 하나씩 해결하고 하나씩 git add 파일이름 을 해도 되고
    - 아니면 모든 파일을 해결하고 git add . 을 해도 된다

  4. github에 리모트 레포지토리를 추가할 때
    4.1 git remote add origin 주어진주소
    - remote: 리모트 레포지토리에 관한 작업을 할 때 쓰는 커맨드
    - add: 새로운 리모트 레포지토리를 등록하겠다는 의미
    - origin 주어진주소: 주어진 주소의 리모트 레포지토리를 origin이란 이름으로 등록하겠다는 의미
    - 위 커맨드를 실행하고 나면 주어진주소를 origin으로 간단하게 나타낼 수 있다
    - origin말고 다른 이름을 써도 되나 origin이 관례

    4.2 git push -u origin master
    - 현재 로컬 레포지토리에 있는 master 브랜치의 내용을 origin이라는 리모트 레포지토리로 보낸다는 뜻
    - 만약 origin에 master 브랜치가 없으면 새로 생성하여 푸시한다
    - -u: --set-upstream의 약자로 로컬 레포지토리에 있는 master 브랜치가 origin에 있는 master 브랜치를 추적하는 걸로 설정
    - 추적이 되면 git pull, git push를 쓸 때, 따로 브랜치를 지정하지 않아도 됨

    4.3 origin과 origin/master의 차이
    - git history를 입력했을 때
    - master가 로컬 레포지토리의 master 브랜치를 나타내고
    - origin/master가 레포지토리의 master 브랜치를 나타낸다

  5. 다른 브랜치들도 push하기
  - 처음 만든 브랜치는 추적이 되어있어 git push로 쉽게 github에 올릴 수 있으나
  - 다른 브랜치는 git push를 쓰면 에러가 난다
  - git push --set-upstream origin 추가할브랜치: 이러면 진행됨

  6. HEAD와 브랜치의 관계
  - HEAD: 어떤 커밋을 가리키는 존재, 그러나 정확히는 어떠한 브랜치를 가리키는 존재
  - 그렇기에 현재 작업하고 있는 브랜치를 HEAD가 가리킨다
  - 즉, git checkout은 HEAD가 가리키는 브랜치를 바꾸는 것이다
  - 머지 커밋: 해드가 가리키던 커밋에 다른 브랜치가 가리키던 커밋을 합쳐서 새로운 커밋을 만드는 작업을 기억할 것

  7. git reset과 HEAD
  - git reset을 사용하면 브랜치가 다른 커밋을 가리키게 된다
  - 그렇기에 HEAD는 동일한 브랜치를 가리키지만 결과적으로 git reset 후 가리키는 커밋은 이전 커밋이 된다
  - 또한 git reset을 통해 이전 커밋을 가도 최신 커밋이 사라지는 것은 아니다
  - 그렇기에 git reset 최신버전커밋 을 이용하여 HEAD와 브랜치가 가리키는 커밋을 최신버전으로 다시 돌릴 수 있다

  8. HEAD의 쓰임새(심화)
    8.1 브랜치를 가리키지 않고 직접 커밋을 가리키는 경우
    - git checkout 커밋아이디를 통해 특정 커밋을 HEAD가 직접 가리키게 할 수 있다
    - 이는 과거 특정 커밋에서 새로운 브랜치를 만들고 싶을 때 사용된다
    - 이때 HEAD를 Detached HEAD라고 한다
    - git checkout 브렌치이름으로 다시 브렌치를 가리키도록 만들 수 있다
  
  9. git reset vs	git checkout
  - HEAD가 가리키던 브랜치가 다른 커밋을 가리키도록 한다 vs	HEAD 자체가 다른 커밋이나 브랜치를 가리키도록 한다
  - HEAD도 결국 간접적으로 다른 커밋을 가리키게되는 효과가 생긴다 vs 브랜치를 통하지 않고, 커밋을 직접적으로 가리키는 HEAD를 Detached HEAD라고 한다

  10. merge의 종류
    10.1 Fast-forward 머지
    - 같은 선상에 있는 두 브랜치를 merge하면 결국 최신버전 커밋으로 브랜치를 이동하는 것뿐이다

    10.2 3-way merge
      10.2.1 단어
      - base : 두 브랜치의 공통 부모 커밋의 sample.txt 파일의 내용 중 일부, 분기 직전 커밋
      - master : 마스터 브랜치의 최신 커밋의 sample.txt 파일의 내용 중 일부 
      - premium : 프리미엄 브랜치의 sample.txt 파일의 내용 중 일부
      - 머지 결과 : master 브랜치에서 premium 브랜치를 머지했을 때의 최종 결과 
      - base - master - premium - 머지 결과 순

      10.2.2 case 1
      - A - A - B - B
      - 3-way merge에선 변화가 발생한 것을 우선적으로 택함
      - 그렇기에 base에서 변화된 값을 가진 premium의 값을 택하여 merge 후에 B로 변경

      10.2.3 case 2
      - 1 - 2 - 1 - 2
      - 3-way merge에선 변화가 발생한 것을 우선적으로 택함
      - 그렇기에 base에서 변화된 값을 가진 master의 값을 택하여 merge 후에 2로 변경

      10.2.4 case 3
      - "hello" - (공백) - "hello" - (공백)
      - 3-way merge에선 변화가 발생한 것을 우선적으로 택함
      - 그렇기에 base에서 변화된 값을 가진 master의 값을 택하여 merge 후에 (공백)으로 변경

      10.2.5 case 4
      - "bye" - "fighting" - "please" - conflict 발생
      - 양쪽 다 변화가 생겼기에 git이 어떤 것을 택하지 못함 -> conflict, 유저가 직접 선택

V. Git 협업하기
  1. git push, git pull
  - git을 사용할 때, 누군가가 다른 컴퓨터에 로컬 레포지토리를 수정하여 리모트 레포지토리에 반영했는데
   나는 그것을 모르고 로컬 레포지토리를 수정하여 내용하여 git push를 하면 에러가 뜬다
  - 즉, 리모트 레포지토리가 수정되어 있기에 그것을 덮어쓰며 반영할 수 없다고 알려준다
  - 이때는 먼저 git pull을 하여 수정된 리모트 레포지토리를 불러와야 한다
  - 주의사항)이때 서로 수정사항이 겹치면 merge 과정에서 conflict가 일어난다
             그때는 conflict를 해결하는 방법대로 진행하면 된다
             (원하는 결과로 수정하고 저장하여 커밋하기)
  - 여러 개발자가 작업할 때, git push가 바로 안 되는 경우가 많다, 그럴 때 git pull을 이용해 먼저 불러오는 것을 기억하자

  2. git fetch
  - git pull은 mergr까지 자동으로 해주지만
  - git fetch는 일단 가져와서 살펴본 후, merge할 지 결정한다
  - git fetch를 하면 우선 origin/레포지토리이름 으로 로컬에 저장된다
  - 그 후, git diff 로컬러페지토리 origin/레포지토리 를 이용하여 둘의 차이를 확인한다
  - 이때, 잘못된 함수가 리모트 레포지토리에 있었다면
    1. 잘못된 코드를 추가한 개발자에게 함수를 지우고 다시 리모트 레포지토리에 올려달라고 하기
    2. 잘못된 부분을 해결하고 git push하기

  - git fetch의 사용처는
    1. 리모트 레포지토리에서 가져온 브랜치의 내용을 머지하기 전 점검해야 할 필요가 있거나
    2. 리모트 레포지토리에 있는 브랜치의 내용과 내가 작성한 코드를 비교해서 잘못된 부분이 없는지 검토할 때

  - 즉, 검토가 필요없이 머지할 때는 git pull, 검토가 필요할 땐, git fetch를 사용

  3. git blame
  - 어떤 파일의 특정 코드를 누가 작성했는지 찾아내기 위한 커맨드
  - git blame 파일이름
  - 커밋 아이디 / (작성자 / 날짜 / ...) / 함수 내용
  - git show를 통해 커밋을 누가 작성한 건지 더 자세히 볼 수 있다

  4. git revert
  - 리모트 레포지토리에 올라간 커밋을 취소할 때 사용
  - 꼭 최신 커밋이 아니여도 중간의 한 커밋과정만 취소할 수 있다
  - git revert 복구할커밋아이디
  - revert을 통해 복구한 커밋은 최신 버전의 이전 커밋과 동일하지만 커밋을 한 번 더 해서 복구하는 이유는
    리모트 레포지토리에 올라간 커밋의 버전과 동일하거나 그것보다 더 최신버전만이 git push가 가능하기 때문이다
    만약 이전 커밋으로 git push를 하면 먼저 git pull을 하라고 에러 메세지가 뜬다
  
  5. 여러 커밋을 취소하기
  - git revert 가장이전버전..취소할 가장 최신 커밋 (이때 가장 이전버전에 입력한 것은 취소되지 않는다)
  - 여러 버전을 한 번에 취소할 수 있다

VI. Git 자유자재로 활용하기
  1. git reset을 하고 다시 최신으로 돌아오려면
  - 만약 git reset(옵션에 상관없이)을 가장 최초버전으로 하면 working directory는 최초커밋으로 돌아간다
  - 그러나 git reset 최신커밋아이디 를 입력하면 최신으로 다시 돌아옴
  - git reflog를 통하여 지금까지의 HEAD를 가리킨 커밋 아이디를 모두 볼 수 있으니 참고

  2. 커밋 히스토리를 보는 다양한 방법
  - 우리는 git log --pretty=oneline(우리는 git history로 alias한 것)으로 로그를 본다
  - git log --pretty=oneline --all --graph
    - --all: 모든 브랜치의 로그를 보여줌
    - --graph: *은 커밋 하나, 여러 갈라짐은 브랜치들의 갈라짐

  3. Git GUI 툴
  - 다양한 GUI 툴이 있으니 그것을 활용하는 것도 방법

  4. git rebase
  - git rebase 합치고싶은 브랜치 -> conflict가 생기면 해결 -> git add . -> git rebase --continue
  - merge처럼 합쳐지는 것이 아니라 현재 작업 중인 브랜치가 리베이스한 브랜치를 지나온 것처럼 합쳐진다
  - 그렇기에 커밋 로그가 깔끔하다
  - merge와 차이점
    1. rebase는 새로운 커밋을 만들지 않는다
    2. rebase로 만들어진 커밋 로그는 merge로 만들어진 커밋 로그보다 깔끔하다

  - 두 브랜치를 합쳤다는 기록이 남아야 하면 merge, 커밋 로그를 깔끔하게 해야하면 rebase

  5. git stash
  - 작업 도중 급하게 다른 브랜치에서 작업해야 할 경우 다른 브랜치로 넘어가려하면 커밋을 하라고 에러메세지가 뜬다
  - 이는 브랜치를 이동하면 작업 내용이 사라지기 때문
  - 이때 git stash를 써서 잠시 작업 내용을 저장하면 된다
    - stack의 형태로 저장(즉, 차곡차곡 넣고 맨 뒤부터 뺀다)
    - 최근 커밋 이후로 작업했던 내용은 모두 스택으로 옮겨지고 working directory 내부는 다시 최근 커밋 상태로 초기화
  - git stash list 를 통해 저장된 작업들을 확인할 수 있다
  - git stash apply를 통해 임시 작업을 다시 불러올 수 있다

  - 또한 잘못된 브랜치에서 작업하고 있었을 때도 git stash를 사용한다
  - git stash는 다른 브랜치에도 불러올 수 있기에 main에서 저장한 것을 premium에서 불러올 수 있다
  - 이때 apply를 통해 가장 최근 것을 불러와도 되지만 확실하게 불러오기 위해
    git stash apply stash이름(예. stash@{0})
  
  - git stash drop stash이름: stash 삭제
  - git stash pop stash이름: stash 작업을 적용하면서 stash에서 삭제, 이름을 입력하지 않으면 가장 최근 것으로 실행

  - 나중에도 필요하다면 git stash apply, 필요없다면 git stash pop

  6. git cherry-pick
  - 자신이 원하는 작업이 들어있는 커밋들만 가져와서 현재 브랜치에 추가하는 것
  - git cherry-pick 커밋아이디

  7. 여러 커밋을 하나의 커밋으로 만들기
  - 여러 커밋들을 했는데 그 중 하나만 사용하고 싶을 때
  - git reset --soft 등으로 HEAD는 이전을 가리키지만 working directory는 그대로 두고 다시 커밋하면 된다
  - 그러면 커밋 로그에 우리가 마지막으로 실행한 하나의 커밋만 남는다

  8. gitignore
  - github에서 레포지토리를 만들 때, .gitignore을 생성할 것인지 결정하는 설정이 있다
  - 이것은 working directory 내에서 마치 존재하지 않는 것처럼 git이 인식해야 하는
  - 즉, git이 무시하는 파일들의 이름이 적혀있는 파일이다
  - 자신이 사용하는 언어를 선택하여 생성하면 여러 파일, 디렉토리 이름이 적혀있다
  - *.py[cod], *.$py.class, *.so(*은 아무 글자, []는 끝나는 글자들 중 하나 -> .pyc, .pyo, .pyd를 합쳐서 .py[cod]로 적음)
  - build/, develop-eggs/ 등 /가 붙은 것은 디렉토리를 의미, 그 디렉토리와 그 안 파일까지 모두 무시하겠다는 의미

  - git이 무시한다는 의미
    - gitignore에 있는 파일명, 폴더명은 git이 인식조차 하지 않는다는 읨
    - 예) git status 했을 때, 변경사항이 있으면 에러로 알려주지만 gitignore에 있으면 따로 알려주지 않음

  9. 그 외의 tip
  (1) git commit이라고만 쓰고 실행하면 커밋 메시지를 입력할 수 있는 텍스트 에디터 창이 뜹니다. 
      거기서 커밋 메시지를 입력하고 저장하고 나면 커밋이 이루어집니다.
  (2) git push와 git pull은 그 작업 단위가 브랜치입니다. 
      예를 들어, master 브랜치에서 git push를 하면 master 브랜치의 내용만 리모트 레포지토리의 master 브랜치로 전송되지, 
      premium 브랜치의 내용이 전송되는 것은 아닙니다.(git push에 --all이라는 옵션을 주면 모든 브랜치의 내용을 전송할 수 있기는 합니다.)