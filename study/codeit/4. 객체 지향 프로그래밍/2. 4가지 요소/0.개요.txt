0. 객체 지향 프로그래밍의 4가지 기둥
- 추상화
- 캡슐화
- 상속
- 다형성

1. 추상화
    1.1 개요
    - 특정 코드를 사용할 때, 필수적인 정보를 제외한 세부정보를 가리는 것
    - 변수나 함수를 사용하는 것도 추상화의 예
    (변수나 함수를 지정하면 값이나 구동방식을 몰라도 사용 가능하기 때문)
    - 또한 list 등의 python 내장함수도 이미 추상화가 되었다 할 수 있음

    1.2 tip
    - 변수, 함수, class 등의 이름을 잘 정의해야 한다.
    - 문서화(docstring)를 잘 한다.

    1.3 문서화
    - """ ~ """ 사이에 함수에 관한 설명들을 적어준다.
    - help(class의 이름)을 실행하면 문서화된 구문만 보여준다.

    1.4 type hinting
    - 변수이름: 타입 = 변수값 
    - ex) num: int = 5 / interest: float = 0.02
    - def deposit(self, amount: float) -> None: 은 함수의 리턴값이 없음을 의미
    - 만약 리턴값이 있으면 리턴값의 타입을 None대신 넣어주면 됨
    - type hinting을 어겨도 error는 나지 않으나 팝업으로 오류를 알려줌


2. 캡슐화
    2.1 두 가지 정의
    - 1번 정의: 객체의 일부 구현 내용에 대한 외부로부터의 직접적인 액세스를 차단하는 것
    - 2번 정의: 객체의 속성과 그것을 사용하는 행동을 하나로 묶는 것

    2.2 1번 정의
    - 변수나 메소드 앞에 __(던더바)를 붙이면 밖에서 호출할 수 없다.
    - 예시)
        def __init__(self, name, age, resident_id):
            """이름, 나이, 주민등록번호"""
            self.name = name
            self.__age = age
            self.__resident_id = resident_id
        
    2.3 2번 정의
    - 변수로 접근하는 방법을 메소드로 한정하는 것
    - 위에 예시에서 나이에 관하여 나이를 바꾸는 메소드, 나이를 확인하는 메소드 등을 사용해서만 접근가능

    2.4 메소드
    - getter 메소드: 변수의 값을 읽는 메소드
    - setter 메소드: 변수의 값을 설정하는 메소드
    - 위의 예시에서 나이는 읽거나 변경이 필요할 수 있으나 주민번호는 변경이 필요하지 않고 공개될 필요가 없기에 메소드들을 추가할 필요가 없음

    2.5 정리
    - 클래스 밖에서 접근 못하게 할 변수, 메소드 정하기
    - 변수나 메소드 이름 앞에 언더바 2개 붙이기
    - 변수에 간접 접근할 수 있게 메소드 추가

    2.6 python에서 캡슐화
    - python은 name mangling을 통해 던더바가 앞에 붙은 변수나 메소드의 이름을 _class의 이름__변수(혹은 메소드)로 변경시킨다.
    - 따라서 _class이름__변수 로 외부에서 불러오면 가능
    - python은 완전한 캡슐화를 지원하지 않음

    2.7 python에서 캡슐화의 용도
    - 변수나 메소드 앞에 _를 붙여 class 밖에서 함부로 접근하지 말라는 경고 용도로 사용(접근은 가능, _는 용도가 없음, 그저 경고용)
    - _가 붙은 변수나 메소드는 필요에 따라서 캡슐화한 것처럼 getter, setter 메소드를 추가해주어야 함

    2.8 property 데코레이터
    - getter, setter 함수를 만들면 함수 호출과 내용을 바꿔주어야 한다.
    - 이러한 번거로움을 없애기 위해 쓰이는 데코레이터
    - @property 를 쓰면 getter, @변수.setter 을 쓰면 _가 붙지 않은 변수를 그대로 써도 함수를 만들 수 있다.
    - 자세한건 "3.신용카드 정보 보호하기 II"를 참고
    
    2.9 변수 사용의 최소화
    - 변수 사용을 최소화하면 코드를 변경해야 할 때, 변경부분이 많이 줄어든다.


3. 상속
    3.1 개요
    - 두 class 사이에 부모-자식 관계를 설정하는 것(ex. 자동차와 벤츠)
    - 자동차는 부모 class, 벤츠는 자식 class

    3.2 방법
    - class 자식class이름(부모class이름):
    - 즉, 변수대신 부모class를 입력
    - help(자식class)를 하면 상속받은 메소드와 상속받은 부모 class도 함께 나옴

    3.3 자주쓰이는 메소드
        3.3.1 mro(Method Resolution Order)
        - '자식class이름.mro()'을 출력하면 상속하는 부모class를 볼 수 있음
        - 클래스가 상속받는 부모 클래스들이 순서대로 담긴 리스트를 리턴
        - mro는 자식 클래스부터 리스트에 입력되기에 오버라이딩하면 자식 클래스 메소드가 실행됨

        3.3.2 isinstance
        - isinstance(a, b) / a: 검사할 인스턴스의 이름, b: 기준 클래스의 이름
        - 클래스의 인스턴스이면 True, 아니면 False를 출력
        - 클래스 이름에 부모 클래스를 입력하여도 True가 나옴
        - 즉, 자식 클래스로 만든 인스턴스는 부모 클래스의 인스턴스이기도 함

        3.3.3 issubclass
        - issubclass(a, b) / a: 검사할 클래스의 이름, b: 기준이 되는 부모 클래스의 이름
        - 상속해주는 부모 클래스가 맞는지 여부에 따라 True 또는 False를 출력
    
    3.4 오버라이딩
    - 부모 클래스에게 상속받은 것을 자식 클래스에 맞게 수정하는 것
    - super() 함수로 부모클래스를 불러올 수 있음
    - 방법은 '4. 배달도 해 주세요.py', '5. 계좌는 다 계좌.py'를 참고

    3.5 다중상속
    - 두 개 이상의 클래스를 상속받는 것
    - 부모 클래스가 두 개 이상이기에 super() 사용이 불가
    - 만약 메소드가 두 클래스에 모두 있다면 mro에서 먼저 있는 클래스 메소드를 실행(클래스 상속 순서로 정해짐)
    - 부모끼리 같은 이름의 메소드를 갖지 않거나 같은 이름의 메소드를 자식클래스에서 오버라이딩 하는 것을 권장


4. 다형성
    4.1 개요
    - 하나의 변수가 서로 다른 클래스의 인스턴스를 가리킬 수 있는 것
    
    4.2 일반상속
    - 같은 메소드를 가지고 있으면 하나의 변수를 이용하여 다른 클래스의 인스턴스를 사용할 수 있다.
    - 그러나 같은 메소드가 없으면 오류가 발생한다.
    - 이를 막기 위하여 같은 변수들을 상속하는 부모클래스를 만들고 isinstance를 이용하여 부모클래스에 속하는 클래스만 사용하도록 만든다.
    - 그러나 상속받는 클래스 중 같은 변수를 오버라이딩하지 않으면 오류가 생기는 건 여전하다.

    4.3 추상클래스
    - 여러 클래스들의 공통점을 추상화해서 모아놓은 클래스
    - abc 모듈에서 ABC(abstract base class)와 abstractmethod를 import해야 한다.
    - 추상클래스는 ABC를 상속받고 메소드 위에 @abstractmethod를 적어 반드시 오버라이딩되도록 만든다.
    - 추상메소드에 type hinting을 하여 return되는 값을 알 수 있도록 하는 것이 좋다.
    - 추상클래스에 일반메소드를 넣어도 상관없다. 오버라이딩할지도 선택하기 나름
    - '6.직각삼각형.py ~ 9.주행 시뮬레이터 만들기.py'의 과제를 살펴볼 것

    4.4 추상클래스 활용
    - 추상메소드에 공통으로 포함하고 싶은 내용을 적은 뒤, 오버라이딩된 자식 메소드 시작부분에 super().부모메소드()를 사용하면 
      모두에게 공통으로 부모메소드가 실행되고 자식메소드 실행
    - 추상클래스가 추상메소드로만 이루어져있으면 다중 상속이 아무 문제없다.
    - 왜냐하면 이들은 자식 클래스에 오버라이딩되는 메소드를 사용하기에 다중 상속이 꼬일 걱정이 없기 때문

    4.5 함수/메소드 다형성
    - 위에서 배운 것은 클래스 다형성이고 대부분은 클래스 다형성을 의미한다.
    - 그러나 함수/메소드도 다형성이 존재한다. 밑에 상황은 예시이다.
    - 옵셔널 파라미터는 맨 뒤에 몰아서 써줘야 한다.
    - 함수를 호출할 때 파라미터 이름을 표시하면 호출 순서가 달라도 상관없다.
    - 개수가 확정되지 않은 파라미터는 맨 뒤에 적고 파라미터 이름 앞에 *을 적으면 된다. 

    4.6 LBYL
    - 실행 전 확인해보는 것
    - '9.주행 시뮬레티어 만들기.py'에 있는 밑의 함수가 그 예시
        def add_vehicle(self, new_vehicle: Vehicle):
            """교통 수단 인스턴스들만 시뮬레이터에 추가될 수 있게 한다"""
            if isinstance(new_vehicle, Vehicle):
                self.vehicle.append(new_vehicle)
            else:
                print("{}은 교통 수단이 아니기 때문에 추가할 수 없습니다.".format(new_vehicle))
    
    4.7 EAFP
    - LBYL와 반대
    - 일단 해보고 문제가 생기면 그때 해결하자
    - try와 except를 이용하여 에러가 나는 것은 제외하는 방향으로 가야한다.
    - '9.주행 시뮬레티어 만들기.py'에 있는 add_vehicle과 start_all_vehicles을 EAFP로 작성한 것이다.
        def add_vehicle(self, new_vehicle: Vehicle):
            """교통 수단 인스턴스들만 시뮬레이터에 추가될 수 있게 한다. 단 new_vehicle은 Vehicle의 인스턴스여야 한다."""
            self.vehicle.append(new_vehicle)

        def start_all_vehicles(self):
            """모든 교통 수단을 주행 시작시킨다"""
            print("모든 교통 수단을 주행 시작시킵니다!\n")
            for veh in self.vehicle:
                try:
                    veh.start()
                except (AttributeError, TypeError):
                    print("{}은 교통 수단이 아닙니다.".format(veh))