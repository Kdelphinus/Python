1. DP(동적 계획법)
- 복잡한 문제를 간단한 여러 하위 문제로 나누어 푸는 방법

    1.1. Memoization
    - 중복되는 계산은 한 번만 계산하고 메모로 저장
    - 하향식 접근(위에서 아래로)
    - 재귀
    - 스택이 너무 쌓여 과부화가 일어날 수 있음
    - 그러나 필요한 값들만 계산

    1.2. Tabulation
    - 상향식 접근(아래서 위로)
    - 테이블을 채워 정리
    - 반복문
    - 중간에 필요없는 것까지 계산하는 단점
    - 피보나치 수열을 구할 때, 모든 값을 저장하는 것이 아니라 


2. Greedy(탐욕법)
- 각 단계마다 지금 당장 좋은 방법만 선택하는 방법

    2.1. 사용할 수 있는 문제
    - 탐욕법을 사용해도 최적해를 구할 수 있는 문제
    - 시간이나 공간적 제약으로 최적해 대신 근사해를 찾는 문제

    2.2. 확인할 부분
    - 탐욕적 선택 속성: 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재하는가
    - 최적 부분 구조: 각 단계에서 항상 최적의 선택만 했을 때, 전체 최적해를 구할 수 있는가


3. Sorting Algorithm
    3.1. Comparisons Sorting Algorithm(비교 방식 알고리즘)
        3.1.1. Bubble Sort
        - n개의 원소를 가진 배열을 정렬할 때, 인접한 두 개의 데이터를 비교하면서 정렬을 진행하는 방식
        - 가장 큰 값을 배열의 맨 끝에다 이동시키면서 정렬하고자 하는 원소의 개수만큼을 두 번 반복
        - 공간 복잡도: O(1)
        - 시간 복잡도: O(n^2)

        3.1.2. Selection Sort
        - n개의 원소를 가진 배열을 정렬할 때, 비교하고 있는 값의 index를 저장한 뒤, 최종적으로 한 번만 바꿔준다
        - 그러나 여러 번 비교하는 것은 마찬가지
        - 공간 복잡도: O(1)
        - 시간 복잡도: O(n^2)

        3.1.3. Insertion Sort
        - n개의 원소를 가진 배열을 정렬할 때, i번째 정렬할 순서라고 가정하면 0부터 i-1까지의 원소들은 정렬되어 있다는 가정
        - i번째 원소와 i-1 ~ 0번째 원소까지 비교하면서 i번째 원소가 비교하는 원소보다 크면 서로의 위치를 바꾸고 작으면 바꾸지 않고 다음 순서의 원소와 비교하며 정렬
        - 이 과정을 정렬하려는 배열의 마지막 원소까지 반복
        - 공간 복잡도: O(1)
        - 시간 복잡도: O(n^2)

        3.1.4. Merge Sort
        - Divide and Conquer을 이용한 방법
        - 더이상 나눠지지 않을 때까지 절반씩 분할하다가 더이상 나누어지지 않으면 자기 자신을 반환한다
        - 그리고 반환된 값끼리 합쳐질 때 비교가 이루어지며 정렬되어 임시 배열에 저장된다
        - 그 후, 임시 배열에 저장된 순서를 합쳐진 값으로 반환하여 배열이 하나남을 때까지 반복한다
        - 공간 복잡도: O(n)
        - 시간 복잡도: O(nlogn)

        3.1.5. Heap Sort
        - 정렬 대상을 힙에 넣었다 꺼내는 방법과 기존의 배열을 heap으로 만들어 꺼내는 방법이 있다
        - heap에 데이터를 저장하거나 삭제하는 시간 복잡도가 O(logn)이고 이 과정이 n번 이루어진다
        - 공간 복잡도: O(1)
        - 시간 복잡도: O(nlogn)

        3.1.6. Quick Sort
        - 정렬 기법 중 가장 빠르나 worst case에선 시간 복잡도가 O(n^2)까지 나올 수 있다
        - 허나 constant factor가 작아서 속도가 빠르다
        - Divide and Conquer을 사용한다

        - pivot으로 설정된 값을 기준으로 좌측은 pivot보다 작은 값, 우측은 pivot보다 큰 값이 위치하도록 partition 한다
        - 이것을 좌, 우측 배열에 각각 재귀적으로 Quick Sort시키면 또 partition된다
        - 이때 pivot으로 설정된 값은 다음 재귀과정에 포함되어선 안 된다

        - 만약 pivot이 항상 최솟값이나 최댓값으로 설정되면 worst case로 시간복잡도가 O(n^2)가 된다
        - 반대로 최상은 pivot이 중간값으로 잡히는 것이다 
        - 그렇기에 pivot을 임의로 설정하여 입력에 관계없이 일정한 수준을 얻도록 한다

            3.1.6.1. Partitioning
            - pivot을 가장 마지막 원소라고 가정할 때, pivot의 index는 k
            - 첫 번째 원소부터 비교하는데 이 값이 pivot보다 작다면 그대로 두고 크다면 맨 k-1번쨰 값과 바꿔준다
            - 모든 원소에 대해 이 과정을 진행한다
            - 마지막 과정에서 작은 값들이 채워지는 인덱스를 가리키고 있는 값에 1을 더한 index값과 pivot값을 바꿔준다
            - 그렇다면 pivot의 새로운 index i를 기준으로 좌측은 pivot보다 작고 우측은 pivot보다 클 것이다

        - 공간 복잡도: O(logn)
        - 시간 복잡도: O(nlogn)

    3.2. non-Comparisons Sorting Algorithm
        3.2.1. Counting Sort
        - 말 그대로 몇 개인지 개수를 세어 정렬하는 방식
        - 정렬하고자 하는 값들 중 최대값에 해당하는 값을 size로 하는 임시 배열 생성
        - 그 후, 정렬하고자 하는 값들이 몇 개인지 파악하여 임시 배열에 저장
        - 개수를 모두 구했다면 임시 배열에 저장된 개수를 바탕으로 오름차순 혹은 내림차순으로 배열에 저장하면 됨
        
        - 점수와 같이 좁은 범위에 존재하는 데이터들을 정렬할 때 유용
        - 공간 복잡도: O(n)
        - 시간 복잡도: O(n)

        3.2.2. Radix Sort
        - 기수 정렬은 정렬하고자 하는 데이터의 길이가 동일하다면 O(nlogn)보다 더 빨리 정렬할 수 있는 방법이다
        
        - 기수(Radix)란 주어진 데이터를 구성하는 기본요소를 의미
        - 하나의 기수마다 하나의 버킷을 생성하여 분류한 후, 버킷 안에서 또 정렬하는 방식
        - 기수 정렬은 LSD(Least Significant Digit) 방식과 MSD(Most Significant Digit)방식으로 나뉜다
            - LSD는 덜 중요한 숫자부터 정렬하는 방식, 예를 들어 숫자를 정려하면 일의 자리부터 정렬하는 방식
            - MSD는 중요한 숫자부터 정렬하는 방식, 예를 들어 숫자를 정렬하면 백의 자리부터 정렬하는 방식
        - 두 개의 Big-O는 동일하지만 기수 정렬은 대부분 LSD를 이야기한다

        - LSD는 중간에 정렬 결과를 볼 수 없다, 즉 모든 정렬이 끝나야 확인이 가능하다
        - MSD는 정렬 중간에 정렬이 될 수 있으나 정렬이 완료되었는지 확인하는 과정이 필요하기에 메모리를 더 사용하게 된다
          또한, 상황마다 일관적인 정렬 알고리즘을 사용하여 정렬하는데 적용할 수 없다
        - 그렇기에 기수 정렬을 논할 땐 주로 LSD에 대해서 논한다

        - 공간 복잡도: O(n)
        - 시간 복잡도: O(n)


4. Prime Number Algorithm
- 소수를 판별하는 알고리즘은 직접 나누어 소수인지 판별하는 것과 에라토스테네스의 체를 이용하는 방법이 있다

    4.1. Eratosthenes' sieve
    - 예를 들어 100이하의 소수를 찾고 싶다면 1부터 100까지 나열한다
    - 1은 소수 제외니 지우고 2부터 10(100의 제곱근)까지 자신의 배수들을 지우고 남은 것이 소수이다

    - 공간 복잡도: O(n)
    - 시간 복잡도: O(loglogn)