0. 들어가기 전에
- 단일 책임 원칙(Single Responsibility Principle)
- 개방 폐쇄 원칙(Open-Closed Principle)
- 리스코프 치환 원칙(Liskov Substitution Principle)
- 인터페이스 분리 원칙(Interface Segregation Principle)
- 의존 관계 역전 원칙(Dependency Inversion Principle)


1. 단일 책임 원칙(Single Responsibility Principle)
  1.1 개요
  - 모든 클래스는 단 한가지의 책임만을 갖고, 
    클래스 안에 정의되어 있는 모든 기능은 이 하나의 책임을 수행하는데 집중되어 있어야 한다.
  - 하나의 클래스로 너무 많은 일을 하지 말고, 딱 한 가지 책임만 수행하라는 뜻
  - 같이 수정할 것은 묶고 따로 수정할 것은 분리하는 것

  1.2 God Object
  - 여러 책임을 가지는 클래스
  - '1. God Object.py'에서 Ship 클래스가 그 예시(연료, 물자, 선원, 엔진을 모두 책임지므로)

  1.3 단일 책임 원칙
  - '2.단일 책임 원칙.py'를 참고
  - 연료, 물자, 선원, 엔진을 각각의 클래스로 나누고 Ship 클래스는 나뉜 클래스의 인스턴스를 사용
  - 단일 책임 원칙을 적용하면 전체 코드 길이는 길어지지만 클래스 하나의 길이는 줄어든다.
  - 이것이 클래스의 의미를 파악하고 수정하기 쉽다.
  - 프로그램이 커질수록 단일 책임 원칙이 중요하다.

  1.4 전체적인 느낌은 '3.모든 것을 아는 학생.py' 참고


2. 개방 폐쇄 원칙(Open-Closed Principle
  2.1 개요
  - 클래스는 확장에 열려 있어야하며, 수정에는 닫혀 있어야한다.
  - 확장에 열려 있는 것: 프로그램의 기존 기능을 확장할 수 있다는 것
  - 수정에 닫혀 있는 것: 한 번 작성한 코드를 바꾸지 않아도 되는 것

  2.2 '4.개방 폐쇄 원칙을 어기는 코드.py'에서 원칙을 어긴 것을 볼 수 있음

  2.3 '5. 개방 폐쇄 원칙.py'
  - 확장에 열려 있음
    -> 추상 클래스 Keyboard를 상속받는 것이면 어떤 것이든 사용 가능

  - 수정에 닫혀 있음
    -> 추상 클래스 Keyboard를 상속받는 것이면 어떤 키보드를 연결해도 
       KeyboardManager를 수정할 필요가 없음

  2.4 isinstance와의 비교
  - 개방 폐쇄 원칙을 지켜 만들면 추상 클래스 Keyboard에 맞춰서만 만들면 됨
  - 그러나 isinstance를 사용하면 연결할 키보드에 맞춰서 KeyboardManager를 수정해야함
  - 그러므로 개방 폐쇄 원칙이 협력하고 수정하기에 훨씬 수월함


3. 리스코프 치환 원칙(Liskov Substitution Principle)
  3.1 개요
  - 부모 클래스의 인스턴스를 사용하는 위치에 자식 클래스의 인스턴스를 사용했을 때
    코드가 원래 의도대로 작동해야 한다.
  - 자식 클래스의 인스턴스는 부모 클래스의 인스턴스이기도 하므로 부모 클래스의 행동규약을 자식클래스가 어기지 말라는 것이다.
  
  3.2 오버라이딩 실수
  - 자식클래스가 오버라이딩을 잘못하면 리스코프 치환 원칙을 어길 수 있다.
  - 첫째: 자식 클래스가 부모 클래스의 변수의 타입을 바꾸거나 메소드의 파라미터 또는 리턴값의 타입이나 갯수를 바꾸는 경우
  - 둘째: 자식 클래스가 부모 클래스의 의도와 다르게 메소드를 오버라이딩 하는 경우

  3.3 첫째 실수
  - '7. 리스코프 치환 원칙을 어기는 코드.py', '8. 리스코프 치환 원칙을 지기는 코드.py' 참고
  - 지키지 않으면 error

  3.4 둘째 실수
  - '9. 행동 규약을 어기는 자식 클래스.py' 참고
  - 지키지 않아도 error가 나지 않음


4. 인터페이스 분리 원칙(Interface Segregation Principle)
  4.1 개요
  - 인터페이스: 추상 클래스 중에서 추상 메소드만 있고 일반 메소드는 없는 것(파이썬에는 없는 개념)
  - 클래스가 사용하지 않을 메소드에 의존할 것을 강요하면 안 된다.
  - 클래스가 나중에 사용하지 않을 메소드를 가지도록 강제하지 말라는 뜻
  - 이는 추상 클래스를 상속 받으면 자식 클래스는 추상 메소드들을 반드시 오버라이딩 하도록 강제하지 말라는 뜻
  - 추상 클래스 -> 인터페이스라고 호칭 변경

  4.2 뚱뚱한 인터페이스
  - '10. 뚱뚱한 인터페이스.py'에서 Memo는 send가 필요없으나 IMessage를 상속받기 위하여 강제로 오버라이딩 해야함
  - 이것이 인터페이스 분리 원칙을 어기는 예시
  - IMessage처럼 너무 많은 메소드를 한 번에 가지는 인터페이스를 뚱뚱한 인터페이스라고 함
  - 뚱뚱한 인터페이스는 인터페이스 분리 원칙을 위반하기 쉬움

  4.3 역할 인터페이스
  - 뚱뚱한 인터페이스를 여러 부분으로 나눈 인터페이스
  - '11. 인터페이스 분리 원칙 적용.py'을 참고
  - IText와 ISendable로 나눔

  4.4 tip
  - 서로 관련 있는 메소드끼리 나누는 것이 원칙
  - 너무 작게 나누어 한 개씩 인터페이스를 나누는 것은 비효율적


5. 의존 관계 역전 원칙(Dependency Inversion Principle)
  5.1 개요
  - 상위 모듈은 하위 모듈의 구현 내용에 의존하면 안 된다.
  - 상위 모듈과 하위 모듈 모두 추상화된 내용에 의존해야 한다.

  5.2 상위 모듈과 하위 모듈
  - '13. 의존 관계 역전 원칙 위배.py'를 예시
  - 상위 모듈: 사용하는 클래스(GameCharacter 클래스)
  - 하위 모듈: 사용당하는 클래스(Sword 클래스)