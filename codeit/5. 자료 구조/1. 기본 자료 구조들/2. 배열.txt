1. 배열 vs 리스트
    1.1 배열
    - c 언어에서 python에 리스트같은 역할
    - 그러나 크기가 고정되어 있고 같은 타입의 데이터만 담을 수 있음
    - 데이터를 직접 메모리에 연속적으로 저장
    - 그렇기에 크기와 타입을 미리 지정해야 함

    1.2 리스트
    - 리스트에는 레퍼런스 4개를 연속적으로 저장
    - 그렇기에 타입이나 크기에 제한받지 않고 리스트를 만들 수 있다.


2. 배열의 데이터 접근법
- 배열의 시작주소(numArray가 가르킴) + 데이터 크기 * 인덱스 = 찾고자 하는 인덱스의 주소
- O(1)으로 저장하고 가져올 수 있다.


3. 배열 탐색
    3.1 개요
    - 배열 안에 값이 있는지 확인하는 것

    3.2 탐색 방법
    - 선형 탐색: 앞에서 차례대로 다 확인하는 것(정렬되지 않는 한 이것이 가장 효율적)
    - 그러므로 O(n)이 걸린다.


4. 배열의 종류
    4.1 정적 배열
        4.1.1 개요
        - 크기 고정(요소 수 제한)
        - 흔히 그냥 배열이라고 부름

        4.1.2 크기가 고정되는 이유
        - 배열은 데이터를 모두 연속적으로 저장해야 한다
        - 그렇기에 크기보다 많은 값을 저장하려 하면 뒤에 공간을 알 수 없기에 크기부터 다시 지정해야 함
        - 그렇다고 처음부터 많은 크기를 할당하면 메모리를 낭비하게 됨

    4.2 동적 배열
        4.2.1 개요
        - 크기 변함(요소 계속 추가 가능)
        - 파이썬 리스트가 동적 배열이라 할 수 있음

        4.2.2 크기가 변할 수 있는 이유
        - 새로운 공간에 원래 배열보다 더 큰 공간(예를 들어 두 배)을 만들어 원래의 값을 복사한다
        - 정적 배열을 이용하여 만들어진 자료 구조
        - 새로운 공간에 남는 공간이 생길지라도 빈 공간에 값이 들어가기 전까진 접근할 수 없다

        4.2.3 추가 연산
            4.2.3.1 정적 배열에 남는 공간이 있을 떄
            - 비어 있는 공간 중 가장 앞에 있는 공간에 추가
            - O(1)

            4.2.3.2 정적 배열이 꽉 찼을 때
            - 기존의 크기보다 큰 공간을 만들고 새 공간에 기존 배열을 복사하고 추가
            - O(n)(복사하는데 걸리는 시간) + O(1)(새 값을 추가하는데 걸리는 시간)
            - O(n + 1) = O(n)
            - 따라서 동적 배열은 빠르면 O(1), 느리면 O(n)이 걸림
            - 그러나 O(1)이 대부분이고 O(n)은 가끔 일어남, 그렇기에 O(n)이라고 하기엔 비합리적


5. 분활 상환 분석
    5.1 개요
    - 같은 동작을 n번 했을 때, 드는 시간이 x이면 동작을 한 번 하는데 걸린 시간은 x/n
    - 시간복잡도를 평균을 내서 이야기하는 것
    - 최악의 경우로 시간복잡도를 이야기하는 것이 비합리적일 때 사용
    - 분활 상환 분석을 한다고 무조건 시간복잡도가 줄어들지는 않으나 줄어들 경우 분활 상환 분석을 사용해도 무방함

    5.2 동적 배열의 분활 상환 분석
        5.2.1 배열 끝에 새로운 데이터를 저장하는데 걸리는 시간
        - O(n)
        - n개의 데이터를 저장하므로(첫번째 데이터를 저장할 땐 첫번째 데이터가 배열 끝 데이터로 생각하기에)

        5.2.2 새로운 배열에 데이터를 옮기는 시간
        - 새로운 배열을 만들 때마다 기존 배열의 2배 크기를 만든다고 할 때
        - 첫번째 추가, 배열 크기: 1, 소요 시간: 0 -> 두번째 추가, 배열 크기:2, 소요 시간: 1 -> 세번째 추가, 배열 크기: 4, 소요 시간: 2
          -> 네번째 추가, 배열 크기: 4, 소요 시간: 0 -> 다섯번째 추가, 배열 크기: 8, 소요 시간: 4 ...
        - 추가 연산을 n번 했을 때, 가장 마지막으로 복사한 시간은 m이라 하면 총 시간은
          m + m/2 + m/4 + ... + 1 로 표현할 수 있음
        - 이는 2m - 1과 같은 값
        - 또한 최근 복사한 수보다 배열의 크기가 무조건 크므로 n > m
        - 즉, 2m - 1 < 2n이므로 O(2n)보단 작음

        5.2.3 두 상황 합치기
        - O(3n)보다 작기에 O(n)으로 표현 가능
        - 이때, O(n)은 추가 연산을 n번 할 때 걸리는 시간 복잡도이므로 n으로 나눠야 함
        - 따라서 추가 연산의 분활 상환 분석을 하면 O(1)이다.

        5.2.4 결론
        - 그렇기에 정확하게는 '동적 배열의 추가 연산은 최악의 경우 O(n)이 걸리지만, 분활 상환 분석을 하면 O(1)이 걸린다'라고 할 수 있다
    

6. 삽입 연산
    6.1 개요
    - 추가 연산은 마지막 자리에 추가하지만 삽입 연산은 원하는 자리에 추가하는 방식

    6.2 정적 배열에 공간이 남은 경우
    - 원하는 자리부터 뒤에 있는 값들을 하나씩 뒤로 밀어넣고 값을 삽입
    - 인덱스 0에 삽입할 때, 모든 값을 하나씩 뒤로 밀어넣고 값을 삽입하므로 O(n + 1)이 걸린다
    - 즉, 시간 복잡도는 O(n)

    6.3 정적 배열이 찼을 때
    - 새로운 배열을 만든 후, 공간이 남은 경우의 절차를 진행
    - O(n) + O(n) + o(1)이 걸림
    - 즉, 시간 복잡도는 O(n)

    6.4 결론
    - 삽입 연산은 배열의 여유 공간의 유무에 상관없이 시간 복잡도가 O(n)


7. 삭제 연산
    7.1 개요
    - 삭제하고 싶은 값 뒤의 인덱스들을 각각 앞 인덱스에 저장
    - 그 후, 개발자가 접근할 수 있는 인덱스 범위도 1을 줄임

    7.2 시간 복잡도
    - 맨 앞의 값을 제거하면 O(n), 맨 뒤의 값을 제거하면 O(1)이 걸림
    - 즉, 시간 복잡도는 O(n)


8. 동적 배열 크기 줄이기
    8.1 개요
    - 삭제 연산 등을 통해 배열이 줄어들면 여유 공간만큼 낭비이므로 배열 크기를 줄여야 함
    - 이는 내부 배열의 사용 비율을 기준으로 공간을 줄이는데 이는 언어마다 다름
    - 여기선 우리는 1/2를 기준으로 함
    - 즉, 8칸의 공간을 가진 배열에서 4개 이하로 사용할 때 4칸으로 배열을 줄임
    - 이때, 칸을 줄이는 배열은 크기를 확장할 때처럼 새로운 내부 배열을 만들고 옮겨 저장

    8.2 시간복잡도
    - 8칸의 공간을 가진 배열이 1개를 지워 7개를 사용할 땐 O(1)
    - 그러나 4개를 지우면 새로운 공간을 할당하므로 O(n)
    - 따라서 시간복잡도는 O(n)

    8.3 분활 상환 분석
    - 새로운 공간을 할당하는 순간은 드물다(7, 6, 5까진 새로운 공간을 할당하지 않음)
    - 그렇기에 크기를 줄이는 건, 추가할 때와 마찬가지로 대부분의 O(1)과 드문 O(n)
    - 결국 크기를 줄이는 과정을 분활 상환 분석할 땐, O(1)이다

    8.4 결론
    - 동적 배열 크기 줄이기는 시간 복잡도는 O(n)이지만, 분활 상환 분석을 하면 O(1)이다


9. 배열 vs 동적 배열 정리
    9.1 연산 & 시간 복잡도
    - 접근: O(1) vs O(1)
    - 탐색: O(n) vs O(n)
    - 삽입: N/A vs O(n), 맨 뒤 O(1)
    - 삭제: N/A vs O(n), 맨 뒤 O(1)
    - 배열은 크기가 정해져 있기에 삽입과 삭제가 불가능

    9.2 낭비하는 공간
    - 배열: 크기가 고정되어 있기에 낭비하는 공간이 없음
    - 동적 배열: 낭비하는 공간이 없을수도, 있을수도 있음 / 새로운 배열을 만들었을 때, 가장 낭비가 큼(n - 2만큼)
    
