1. key-value 데이터
- 알고 있는 정보를 이용하여 값을 구하는 형태
- 하나의 key 당 하나의 value만 있어야 한다.

2. Direct Access Table
- key를 배열의 인덱스로 사용하면 value의 접근이 O(1)이다.
- 그러나 이것은 공간을 많이 낭비할 수 있다.
- 예시) 101호~942호 중 입주한 5명의 데이터를 저장하면 5을 제외한 나머지 공간이 모두 낭비

3.해시 테이블
    3.1 해시 함수
    - 특정 값을 원하는 범위의 자연수로 바꿔주는 함수
    - 똑같은 key를 넣었을 때, 항상 같은 값이 나와야 한다.
    - 결과값이 한 숫자에 치우치지 않고 나올 수 있는 모든 숫자의 출현 확률이 동일해야 한다.
    - 해시 함수는 계산이 빨라야 한다(해시테이블과 연동되는 경우가 많으므로).

        3.1.1 나누기 방법
        - 자연수 key를 해시 테이블의 크기로 나눈 나머지를 리턴하는 방법
        - 크기가 200인 배열에 40, 120, 788, 2307을 넣으면 값은 각각 40, 120, 180, 107이 리턴됨

        3.1.2 곱셈 방법
        - 0과 1사이의 소수 a를 임의로 정한다.
        - key를 a에 곱하여 소수 부분만 남긴다.
        - 남은 소수 부분에 배열의 크기를 곱하여 정수부분만 남기고 이를 리턴한다.
        
        3.1.3 파이썬 hash 함수
        - 파이썬 내부의 hash 함수
        - 그러나 임의의 범위 내가 아닌 아무 정수로 바꾼다.
        - 그대신 불변형 타입은 모두 고유의 정수로 바꿀 수 있다.
        - 불변형 타입: 불린형, 정수형, 소수형, 튜플, 문자열 등

    
    3.2 해시 테이블
    - 원하는 크기의 배열을 만든다.
    - 키를 해시 함수에 넣고 나온 값을 인덱스로 갖는다.
    - 인덱스의 값은 원래 키와 값을 모두 갖는다.
    - 접근은 동일하게 O(1)이고 고정된 크기의 배열을 만드므로 공간의 낭비도 많지 않다.

    3.3 해시 테이블 충돌과 Chaining 
        3.3.1 충돌
        - 한 인덱스에 두 값이 들어가게 되는 경우

        3.3.2 Chaining
        - 충돌하는 값들을 묶어서 저장하는 방법
        - 링크드 리스트를 이용
        - 노드에 key, value, next 세 가지 속성을 가지며 같은 해쉬에 있는 함수를 링크드 리스트로 작성
        - 'LLFH.py' 참고

4. Chaining을 사용한 해시테이블
    4.1 탐색
    - 원하는 key에 해당하는 value를 리턴
    - key를 해시 함수에 넣고 그 결과값의 인덱스로 이동
    - 그 후, 링크드 리스트를 돌며 원하는 키를 가지고 있는지 확인하며 값을 찾으면 리턴
    - 해시 함수 계산: O(1), 배열 인덱스 접근: O(1), 링크드 리스트 노드 탐색: O(n)
    - 즉, O(1 + 1 + n) = O(n)

    4.2 삽입
    - key-value의 값을 저장하거나 수정
    - key를 해시 함수에 넣고 그 결과값의 인덱스로 이동
    - 탐색하며 같은 key가 있으면 삽입된 value로 수정하고 같은 key가 없으면 링크드 리스트 맨 뒤에 추가
    - 해시 함수 계산: O(1), 배열 인덱스 접근: O(1), 링크드 리스트 노드 탐색: O(n), 링크드 리스트 노드 저장/노드 수정: O(1)
    - 즉, O(1 + 1 + n + 1) = O(n)

    4.3 삭제
    - key에 해당하는 key-value를 지움
    - key를 해시 함수에 넣고 그 결과값의 인덱스로 이동
    - 링크드 리스트를 탐색하며 원하는 key의 값을 지움
    - 해시 함수 계산: O(1), 배열 인덱스 접근: O(1), 링크드 리스트 노드 탐색: O(n), 링크드 리스트 노드 삭제: O(1)
    - 즉, O(1 + 1 + n + 1) = O(n)

    4.4 평균 시간 복잡도
    - 하나의 인덱스의 모든 값이 들어갈 확률은 적기에 각각의 인덱스에 평균의 노드만 들어갔다고 가정하여 계산
    - key-value의 총 수: n, 배열의 인덱스 수: m, 링크드 리스트들의 평균 길이: n/m
    - 따라서 평균적으로 O(n/m)이 걸림
    - 이때, m과 n이 항상 어느 정도 같은 값을 유지한다고 가정하면 O(1)

    4.5 결론
    - 즉, 해시 테이블 삽입, 삭제, 탐색 연산들은 최악의 경우 O(n)이 걸리지만, 평균적으론 O(1)이 걸린다

5. Open Addressing
    5.1 개요
    - 충돌이 일어났을 때, 비어있는 다른 인덱스를 찾아 넣는 것
    
    5.2 비어있는 인덱스를 찾는 법
        5.2.1 선형 탐사
        - 충돌이 일어났을 때, 한 칸씩 다음 인덱스가 비었는지 확인하는 것
        - 충돌이 일어난 인덱스부터 비어있능 인덱스를 하나씩 순서대로 선형적으로 찾는 방법

        5.2.2. 제곱 탐사
        - 제곱으로 탐사하는 것
        - 예를 들어 해시 함수의 결과가 10이 나왔을 때, 인덱스 10이 이미 저장되어 있다면
        - 1의 제곱인 1을 더하여 인덱스 11을 확인
        - 그래도 있다면 2의 제곱인 4를 더하여 15를 확인
        - 그래도 있다면 3의 제곱인 9를 더하여 24를 확인 하는 것
    
    5.3 탐색 연산
    - 선형 탐사를 이용하여 데이터를 찾는다.
    - 해시 함수를 통해 나온데 인덱스에 값이 나올 때까지 선형 탐색
    - 만약 빈 인덱스가 나오면 저장이 되어 있지 않은 것

    5.4 삭제 연산
    - 해시 함수에 넣어 인덱스를 찾는다.
    - 그 후, 선형탐색을 통하여 데이터를 찾는다.
    - 빈 칸을 'deleted' 등으로 저장하면서 탐색의 방해가 가지 않도록 값을 저장해둔다.

    5.5 시간 복잡도
    - 탐사의 경우, 최악이 O(n)이고 나머지 연산은 모두 O(1)이다.
    - 그렇기에 시간 복잡도는 모두 O(n)이다.

    5.6 평균 시간 복잡도
    - 시간 복잡도에선 해시 테이블이 사용하는 배열이 거의 꽉 찼을 경우, 즉 최악의 경우를 이용해서 분석
    - 그러나 실제로 그런 일은 거의 일어나지 않음. 따라서 평균 시간 복잡도로 표현

        5.6.1 load factor
        - m: 해시 테이블이 사용하는 배열의 크기
        - n: 해시 테이블 안에 들어 있는 데이터 쌍 수
        - load factor = n/m < 1
        - 빈 인덱스를 i번 이상 탐색해야 할 확률
          p_i= n/m * n-1/m-1 * n-2/m-2 ... n-i+2/m-i+2 < (n/m)^i-1
    - E(기대값) = p_1 + p_2 + ...
    - E < 1 + n/m + (n/m)^2 + (n/m)^3 + ... 이고 n/m < 1 이므로 등비수열의 합을 이용하면
    - E < 1/(1-(n/m))
    - n/m이 0.5일 때, 즉 반 정도 테이블이 차있어도 E는 2보다 작다.
    - 이는 2개의 인덱스만 확인해봐도 빈칸을 찾을 수 있다는 것
    - 그렇기에 평균적으론 O(1)이 걸린다.
