# Recursion

## 1. 개요

재귀는 정의 단계에서 자신을 재참조하는 함수이다. 프랙탈같이 자신의 모양이 반복적으로 나오는 것 역시 재귀라고 할 수 있다.
  
재귀 함수는 이러한 재귀적 특정을 가져와 자기 자신을 계속하여 호출하는 함수를 의미한다.
그렇기에 동일한 구조의 문제가 계속해서 반복되는 문제에서 큰 성능을 발휘한다.

## 2. 설명

재귀 함수의 정의만 보면 위 사진처럼 항상 참인 whlie문과 같이 계속하여 자기 자신을 불러오는 함수가 된다. 
이는 영원히 반복되다가 콜스택 초과로 프로그램이 강제 종료되는 치명적인 문제를 야기한다. 
그렇기에 재귀 함수는 종결 조건이 반드시 필요하다.  

종결 조건은 간단하게 반복문의 조건과 동일한 역할을 한다고 보면 된다. 


## 3. 반복문과의 차이점

재귀는 자기 자신을 불러오기에 코드가 간단해지는 큰 장점이 있다. 
그러나 함수를 호출할 때마다 콜스택이 쌓이기에 메모리적으로 부담이 생길 수 있다. 
일례로 python은 함수 깊이 제한을 기본 1000으로 정의되어 있다.

그러나 재귀를 사용하면 직관적으로 구조를 확인할 수 있는 문제들(ex. 하노이 탑, 팩토리얼 등)이 있고 요즘 컴파일러들은 재귀 호출 최적화를 잘 하기 때문에 너무 재귀를 불신할 필요도 없다.
즉 상황에 따라 잘 사용하면 된다.  

## 4. 꼬리 재귀

재귀는 장점만큼이나 단점이 아주 명확하다. 그래서 재귀 함수의 장점을 살리고 단점을 보완하는 방법 중 하나로 **꼬리 재귀**를 사용하기도 한다.
  
꼬리 재귀는 **재귀 호출이 끝나면 아무 일도 하지 않고 결과만 바로 반환되도록 하는 방법**이다. 
즉, 함수의 결과값은 return 되기 전에 정해지며 결과값만 계속해서 반환된다. 
이 방식은 이전 함수의 상태를 유지하지도 않고 추가 연산을 하지도 않기에 스택이 넘쳐나는 문제를 해결할 수 있다. 

팩토리얼 코드를 통해 일반 재귀와 꼬리 재귀를 비교해보면 다음과 같다.
(이 [블로그](https://joooing.tistory.com/entry/%EC%9E%AC%EA%B7%80-%E2%86%92-%EA%BC%AC%EB%A6%AC-%EC%9E%AC%EA%B7%80-Tail-Recursion) 의 설명과 사진을 이용하니 자세하게 보고 싶다면 참고할 것)

### 4.1 일반 재귀
```python
def factorial(n: int):
    if n == 1:
        return 1
    return n * factorial(n - 1)
```
return 값에서 알 수 있듯이 n에서부터 하나씩 줄여가며 스택이 차례대로 쌓이게되고 종결조건에 도달하면 쌓인 스택을 제거하면서 받은 값으로 계산하여 리턴하는 형태이다. 

블로그의 있는 그림이 더 참고하면 더 이해하기 편하다. 

![의인화](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FISHzh%2FbtqSTItCl1V%2FntnZlqRZbex9roPON36bQk%2Fimg.png)

### 4.2 꼬리 재귀
```python
def factorial(n: int, total = 1: int):
    if n == 1:
        return 1
    return factorial(n - 1, n * total)
```
일반 재귀와 차이점은 바로 return부분이다. 앞서 설명한 것과 같이 꼬리 재귀는 재귀 호출이 끝나면 아무 것도 하지 않고 결과만 바로 반환하는 방법이다. 
그렇기에 코드 마지막 부분에서 일반 재귀와 다르게 이미 계산이 끝난 total이란 변수가 있음을 볼 수 있다.
  
이 역시 블로그의 그림을 보면 더 쉽게 이해할 수 있다. 

![의인화2](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F5lSPw%2FbtqSTJzm2ML%2FLGY8UmInnpSTEIygXXOKpk%2Fimg.png)

### 4.3 이게 왜 효율적인가

그림과 코드만 본다면 같은 수의 스택을 쌓는 문제를 알 수 있다. 그렇다면 왜 꼬리 재귀는 일반 재귀보다 효율적인가?  
  
일반 재귀는 return에서 원래 자기가 가지고 있는 값을 곱해야 한다. 
그렇기에 함수에서 사용한 n이 어디 저장되어 있는지 기억해야 한다. 그러나 꼬리 재귀는 마지막에 연산이 없기에 자리를 기억할 필요가 없다. 
이 차이가 일반 재귀보다 꼬리 재귀가 더 효율적인 이유이다. 

## 5. Python의 경우

앞서 꼬리 재귀에 대해 많은 설명을 보고 코드도 비교했지만 아쉽게도 python은 꼬리 재귀 최적화를 지원하지 않는다.
그렇기에 꼬리 재귀 방식으로 코드를 작성해도 자리를 잊지 않기 때문에 작동에 있어 차이가 생기지 않는다.  
  
또한 python은 기본적으로 재귀가 최대 1000번으로 제한되어 있다.
그렇기에 어지간히 간단한 재귀가 아닌 이상 무조건 함수 깊이 제한에 막힌다. 
따라서 일반적으로 아래와 같이 함수 깊이 제한을 늘려놓고 하는 것이 일반적이다. 

```python
import sys

sys.setrecursionlimit(10 ** 8)
```
